package factorial;import dataView.*;import coreVariables.*;public class FactorialTerms {	static final public int OFF_DISABLED = 0;	static final public int OFF_ENABLED = 1;	static final public int ON_DISABLED = 2;	static final public int ON_ENABLED = 3;		private String[][] termKey;			//	all main effect keys, all 1-factor interaction keys, etc	private int activeKeys[][];			//	OFF_DISABLED, OFF_ENABLED, ON_DISABLED or ON_ENABLED	private int[][] currentModel;		//	using notation [034][123] or similar		public FactorialTerms(String[][] termKey) {		this.termKey = termKey;	}		public void changeModel(int[][] newModel) {		currentModel = newModel;		setActiveKeys(newModel);	}		public String[] getMainEffectKeys() {		return termKey[0];	}		public String[][] getTermKeys() {		return termKey;	}		public int[][] getActiveKeys() {		return activeKeys;	}		public int[][] getCurrentModel() {		return currentModel;	}		public String[] lineariseKeys() {		int nFactors = termKey[0].length;		int nTerms = 0;		int nInteractions = 1;		for (int i=0 ; i<termKey.length ; i++) {			nInteractions = (nInteractions * (nFactors - i)) / (i + 1);						if (termKey[i].length != nInteractions)				throw new RuntimeException("Wrong number of interaction terms for MultiFactorModel");			else {				for (int j=0 ; j<termKey[i].length ; j++)					if (activeKeys[i][j] > OFF_ENABLED)						nTerms ++;			}		}		String xKeys[] = new String[nTerms];		int index = 0;		for (int i=0 ; i<termKey.length ; i++)			for (int j=0 ; j<termKey[i].length ; j++)				if (activeKeys[i][j] > OFF_ENABLED)					xKeys[index ++] = termKey[i][j];		return xKeys;	}		private int indexOfTerm(int terms[]) {		int cumulative = 0;		for (int level=0 ; level<terms.length ; level++) {			for (int lastTerm=0 ; lastTerm<terms[level] ; lastTerm++) {//				System.out.println("No of terms ending " + lastTerm + " at level "//																+ level + " = " + nTermsEnding(lastTerm, level));				cumulative += nTermsEnding(lastTerm, level);			}		}		return cumulative;	}		private int nTermsEnding(int lastTerm, int level) {															//	 lastTerm choose level		if (level > lastTerm / 2)			level = lastTerm - level;		if (level < 0)			return 0;		int result = 1;		for (int i=0 ; i<level ; i++)			result = (result * (lastTerm - i)) / (i + 1);		return result;	}		private void setActiveKeys(int[][] model) {		activeKeys = new int[termKey.length][];		for (int i=0 ; i<termKey.length ; i++)			activeKeys[i] = new int[termKey[i].length];		//	default OFF_DISABLED				for (int i=0 ; i<model.length ; i++) {			int modelTerm[] = model[i];//			printIntArray("Finding terms for model ", modelTerm);			for (int interactLevel=0 ; interactLevel<modelTerm.length ; interactLevel++) {//				System.out.println("Interaction level: " + interactLevel);				int index[] = new int[interactLevel + 1];				int term[] = new int[interactLevel + 1];				for (int j=0 ; j<=interactLevel ; j++)					index[j] = j;							//	index[] holds index into subset of modelTerm[] 				do {					for (int j=0 ; j<=interactLevel ; j++)						term[j] = modelTerm[index[j]];//					printIntArray("Subset of terms: ", term);					int termIndex = indexOfTerm(term);//					System.out.println("Index in interaction list: " + termIndex);					activeKeys[interactLevel][termIndex] = ON_DISABLED;				}				while (updateIndices(index, modelTerm.length));			}							int termIndex = indexOfTerm(modelTerm);//			System.out.println("Index of interaction " + (modelTerm.length - 1) + " in list: " + termIndex);			activeKeys[modelTerm.length - 1][termIndex] = ON_ENABLED;		}				findOffEnabledKeys();	}		private void findOffEnabledKeys() {									// finds keys that are inactive but with all lower level interactions active		int nFactors = termKey[0].length;		for (int interactLevel=0 ; interactLevel<activeKeys.length ; interactLevel++) {			int targetTerm[] = new int[interactLevel + 1];			for (int i=0 ; i<=interactLevel ; i++)				targetTerm[i] = i;						int index = 0;			do {				if (activeKeys[interactLevel][index] == OFF_DISABLED && allSubtermsEnabled(targetTerm))					activeKeys[interactLevel][index] = OFF_ENABLED;				index ++;			}			while (updateIndices(targetTerm, nFactors));		}	}		private boolean allSubtermsEnabled(int[] targetTerm) {		for (int interactLevel=0 ; interactLevel<targetTerm.length-1 ; interactLevel++) {//				System.out.println("Interaction level: " + interactLevel);			int index[] = new int[interactLevel + 1];			int term[] = new int[interactLevel + 1];			for (int j=0 ; j<=interactLevel ; j++)				index[j] = j;						//	index[] holds index into subset of targetTerm[] 			do {				for (int j=0 ; j<=interactLevel ; j++)					term[j] = targetTerm[index[j]];//					printIntArray("Subset of terms: ", term);				int termIndex = indexOfTerm(term);//					System.out.println("Index in interaction list: " + termIndex);				if (activeKeys[interactLevel][termIndex] < ON_DISABLED)					return false;			}			while (updateIndices(index, targetTerm.length));		}		return true;	}		public int[][] activateTerm(int level, int termIndex, boolean onNotOff) {		int nFactors = termKey[0].length;		boolean[][] active = new boolean[termKey.length][];		for (int i=0 ; i<termKey.length ; i++) {			active[i] = new boolean[termKey[i].length];			for (int j=0 ; j<active[i].length ; j++)				active[i][j] = (activeKeys[i][j] >= ON_DISABLED);		}		active[level][termIndex] = onNotOff;				for (int interactLevel=0 ; interactLevel<active.length-1 ; interactLevel++) {//				System.out.println("Interaction level: " + interactLevel);			int term[] = new int[interactLevel + 1];			for (int j=0 ; j<=interactLevel ; j++)				term[j] = j;			int index = 0;			do {				if (active[interactLevel][index]) {//					printActive("currently active", active);//					System.out.println("deactivating " + interactLevel + ", " + index);					deactivateHierarchical(term, active);				}				index ++;			}			while (updateIndices(term, nFactors));		}		//		printActive("final active", active);				return findModel(active);	}/*		private void printActive(String title, boolean[][] active) {		System.out.println(title);		for (int i=0 ; i<active.length ; i++) {			System.out.print("level " + i + ": ");			for (int j=0 ; j<active[i].length ; j++)				System.out.print(active[i][j] ? "t " : "f ");			System.out.print("\n");		}	}*/		private void deactivateHierarchical(int[] targetTerm, boolean[][] active) {		for (int interactLevel=0 ; interactLevel<targetTerm.length-1 ; interactLevel++) {//				System.out.println("Interaction level: " + interactLevel);			int index[] = new int[interactLevel + 1];			int term[] = new int[interactLevel + 1];			for (int j=0 ; j<=interactLevel ; j++)				index[j] = j;						//	index[] holds index into subset of targetTerm[] 			do {				for (int j=0 ; j<=interactLevel ; j++)					term[j] = targetTerm[index[j]];//					printIntArray("Subset of terms: ", term);				int termIndex = indexOfTerm(term);//					System.out.println("Index in interaction list: " + termIndex);				active[interactLevel][termIndex] = false;			}			while (updateIndices(index, targetTerm.length));		}	}		private int[][] findModel(boolean[][] active) {		int nTerms = 0;		for (int i=0 ; i<active.length ; i++)			for (int j=0 ; j<active[i].length ; j++)				if (active[i][j])					nTerms ++;				int[][] model = new int[nTerms][];		int termIndex = 0;		for (int i=0 ; i<active.length ; i++)			for (int j=0 ; j<active[i].length ; j++)				if (active[i][j]) {					model[termIndex] = indexToTerm(j, i);					termIndex ++;				}		return model;	}		private int[] indexToTerm(int termIndex, int interactLevel) {		int nFactors = termKey[0].length;		int[] term = new int[interactLevel + 1];		for (int j=0 ; j<=interactLevel ; j++)			term[j] = j;				int index = 0;		do {			if (index == termIndex)				break;			index ++;		}		while (updateIndices(term, nFactors));				return term;	}		private boolean updateIndices(int[] index, int nVars) {						//	cycled through all combinations of indices from {0,1,...,k-1} to {n-k,..., n-1}		for (int i=0 ; i<index.length ; i++)			if ((i == index.length - 1) && index[i] < nVars - 1											|| (i < index.length - 1) && index[i] < index[i + 1] - 1) {				index[i] ++;				for (int j=0 ; j<i ; j++)					index[j] = j;				return true;			}		return false;	}	/*	private void printStringArray(String title, String[] keys) {		System.out.print(title);		for (int i=0 ; i<keys.length ; i++)			System.out.print(" " + keys[i]);		System.out.print("\n");	}		private void printIntArray(String title, int[] indices) {		System.out.print(title);		for (int i=0 ; i<indices.length ; i++)			System.out.print(" " + indices[i]);		System.out.print("\n");	}*/		public Value[] createXVector(DataSet data, int[] xIndex) {		//	indices for all main effect vars		String[] mainEffectKeys = termKey[0];		int nFactors = mainEffectKeys.length;		int nTerms = 0;		int nInteractions = 1;		for (int i=0 ; i<termKey.length ; i++) {			nInteractions = (nInteractions * (nFactors - i)) / (i + 1);			if (termKey[i].length != nInteractions)				throw new RuntimeException("Wrong number of interaction terms for MultiFactorModel");			else {				for (int j=0 ; j<termKey[i].length ; j++)					if (activeKeys[i][j] > OFF_ENABLED)						nTerms ++;			}		}				Value allXValues[] = new Value[nTerms];		int allXIndex = 0;		for (int i=0 ; i<mainEffectKeys.length ; i++)			if (activeKeys[0][i] > OFF_ENABLED) {				CatVariable xCatVar = (CatVariable)data.getVariable(mainEffectKeys[i]);				allXValues[allXIndex ++] = xCatVar.getLabel(xIndex[i]);			}				for (int i=1 ; i<termKey.length ; i++)			for (int j=0 ; j<termKey[i].length ; j++)				if (activeKeys[i][j] > OFF_ENABLED) {					InteractionVariable interVar = (InteractionVariable)data.getVariable(termKey[i][j]);					allXValues[allXIndex ++] = interVar.valueFromMainEffects(xIndex);				}		return allXValues;	}}