package models;import java.awt.*;import java.util.*;import dataView.*;import axis.*;public class LinearModel extends CoreModelVariable {	static final public NumValue kZero = new NumValue(0.0, 0);		protected NumValue b0, b1, s1;	protected double se_b0, se_b1;	private boolean sdDrag;	private boolean fixedIntercept = false;		private double sx, sxx;		//	used to calculate leverage later	private int n;		private double minResidSelection = 0.0;	private double maxResidSelection = 0.0;		public LinearModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1,																															NumValue s0, NumValue s1) {		super(name, data, xKey);		this.b0 = b0;		this.b1 = b1;		this.s0 = s0;		this.s1 = s1;	}		public LinearModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1,																																								NumValue s0) {		this(name, data, xKey, b0, b1, s0, kZero);	}		public LinearModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1) {		this(name, data, xKey, b0, b1, kZero, kZero);	}		public LinearModel(String name, DataSet data, String xKey, String params) {		super(name, data, xKey);		s1 = kZero;		setParameters(params);	}		public LinearModel(String name, DataSet data, String xKey) {														//		only for situations where parameters														//		are set by LS immediately after		super(name, data, xKey);		s1 = kZero;	}		public void setParameters(String params) {		StringTokenizer theParams = new StringTokenizer(params);				b0 = new NumValue(theParams.nextToken());		b1 =new NumValue(theParams.nextToken());		if (theParams.hasMoreTokens()) {			s0 = new NumValue(theParams.nextToken());			if (theParams.hasMoreTokens())				s1 = new NumValue(theParams.nextToken());		}	}		public void setParameters(NumValue b0, NumValue b1) {		this.b0 = b0;		this.b1 = b1;	}		public void setIntercept(NumValue b0) {		this.b0 = b0;	}		public void setIntercept(double b0Value) {		b0.setValue(b0Value);	}		public void setSlope(NumValue b1) {		this.b1 = b1;	}		public void setSlope(double b1Value) {		b1.setValue(b1Value);	}		public void setMinResidSelection(double min) {		minResidSelection = min;	}		public void setMaxResidSelection(double max) {		maxResidSelection = max;	}		public double getMinResidSelection() {		return minResidSelection;	}		public double getMaxResidSelection() {		return maxResidSelection;	}		public int noOfParameters() {		return 2;	}		public void setLSParams(String yKey, int intDecs, int slopeDecs, int sdDecs) {		ValueEnumeration xe = ((NumVariable)data.getVariable(xKey[0])).values();		ValueEnumeration ye = ((NumVariable)data.getVariable(yKey)).values();		sx = 0.0;		double sy = 0.0;		sxx = 0.0;		double sxy = 0.0;		double syy = 0.0;		n = 0;		int index = 0;		while (xe.hasMoreValues() && ye.hasMoreValues()) {			double x = xe.nextDouble();			double y = ye.nextDouble();			if (!Double.isNaN(x) && !Double.isNaN(y)) {				if (index != deletedIndex) {					sx += x;					sy += y;					sxx += x * x;					sxy += x * y;					syy += y * y;					n ++;				}				index ++;			}		}		sxx -= sx * sx / n;		sxy -= sx * sy / n;		syy -= sy * sy / n;				b1 = new NumValue(sxy / sxx, slopeDecs);		b0 = new NumValue((sy - sx * b1.toDouble()) / n, intDecs);		s0 = new NumValue((n > 2) ? Math.sqrt((syy - b1.toDouble() * sxy) / (n - 2)) : 0.0, sdDecs);				se_b1 = s0.toDouble() / Math.sqrt(sxx);		double xMean = sx / n;		se_b0 = s0.toDouble() * Math.sqrt(1.0 / n + xMean * xMean / sxx);	}		public void updateLSParams(String yKey) {		int intDecs = (b0 == null) ? 0 : b0.decimals;		int slopeDecs = (b1 == null) ? 0 : b1.decimals;		int sdDecs = (s0 == null) ? 0 : s0.decimals;		setLSParams(yKey, intDecs, slopeDecs, sdDecs);	}		public NumValue getIntercept() {		return b0;	}		public NumValue getSlope() {		return b1;	}		public double getSeIntercept() {		return se_b0;	}		public double getSeSlope() {		return se_b1;	}		public double evaluateMean(double x) {		return b0.toDouble() + x * b1.toDouble();	}		public double evaluateMean(Value[] x) {		return evaluateMean(((NumValue)x[0]).toDouble());	}		public NumValue evaluateSD(Value x) {		return new NumValue(s0.toDouble() + ((NumValue)x).toDouble() * s1.toDouble(), s0.decimals);	}		public void setDecimals(int decimals, int slopeDecimals) {		b0.decimals = decimals;		b1.decimals = slopeDecimals;		s0.decimals = decimals;	}		protected void drawSegment(double x0, double y0, double x1, double y1,							Graphics g, PositionFinder finder, Point p0, Point p1) {		if (finder.sameX(x0, x1) && (finder.notFinite(y0) || finder.notFinite(y1)))			return;				double xMid = (x0 + x1) * 0.5;		double yMid = evaluateMean(xMid);				if (finder.nearlyLinear(y0, yMid, y1) || finder.sameX(x0, x1)) {			p0 = finder.findPoint(x0, y0, p0);			p1 = finder.findPoint(x1, y1, p1);			if (p0.y >= -100 && p0.y <= 1000 && p1.y >= -100 && p1.y <= 1000)																//		ad hoc check for way-out points				g.drawLine(p0.x, p0.y, p1.x, p1.y);		}		else {			drawSegment(x0, y0, xMid, yMid, g, finder, p0, p1);			drawSegment(xMid, yMid, x1, y1, g, finder, p0, p1);		}	}		static final private boolean LOW = true;	static final private boolean HIGH = false;		protected double inverseEvaluate(double y, boolean lowNotHigh) {											//		lowNotHigh only needed for quadratic		return (y - b0.toDouble()) / b1.toDouble();	}		protected boolean positiveSlopeOnRight(double x) {		return b1.toDouble() > 0.0;	}		protected boolean positiveCurvature() {		return false;	}		protected void drawMonotonic(double xLow, double xHigh, Graphics g, PositionFinder finder) {		double x0 = xLow;		double y0 = evaluateMean(xLow);		if (y0 < finder.yMin) {			if (!positiveSlopeOnRight(xLow))				return;			else {				x0 = inverseEvaluate(finder.yMin, positiveCurvature() ? HIGH : LOW);				if (x0 > xHigh)					return;				y0 = evaluateMean(x0);			}		}		else if (y0 > finder.yMax) {			if (positiveSlopeOnRight(xLow))				return;			else {				x0 = inverseEvaluate(finder.yMax, positiveCurvature() ? LOW : HIGH);				if (x0 > xHigh)					return;				y0 = evaluateMean(x0);			}		}		double x1 = xHigh;		double y1 = evaluateMean(xHigh);		if (y1 < finder.yMin) {										//		slope must be <= 0			x1 = inverseEvaluate(finder.yMin, positiveCurvature() ? LOW : HIGH);																			//		x1 must be > xLow			y1 = evaluateMean(x1);		}		else if (y1 > finder.yMax)	 {								//		slope must be >= 0			x1 = inverseEvaluate(finder.yMax, positiveCurvature() ? HIGH : LOW);																			//		x1 must be > xLow			y1 = evaluateMean(x1);		}				Point p0 = new Point(0, 0);		Point p1 = new Point(0, 0);		drawSegment(x0, y0, x1, y1, g, finder, p0, p1);	}		public void drawMean(Graphics g, DataView view, NumCatAxis xAxis, NumCatAxis yAxis) {		PositionFinder finder = new PositionFinder(view, xAxis, yAxis);//		if (b1.toDouble() == 0.0)//			drawSegment(xAxis.minOnAxis, xAxis.maxOnAxis, g, finder);//		else			drawMonotonic(finder.xMin, finder.xMax, g, finder);	}		public void drawModel(Graphics g, DataView view, NumCatAxis xAxis,											NumCatAxis yAxis, Color fillColor, Color meanColor) {		PositionFinder finder = new PositionFinder(view, xAxis, yAxis);		double lowX = xAxis.minOnAxis;		double highX = xAxis.maxOnAxis;		double xBorder = (highX - lowX) * 0.1;		lowX -= xBorder;		highX += xBorder;				g.setColor(fillColor);				double yOffset = 2.0 * evaluateSD().toDouble();				double lowY1 = evaluateMean(new NumValue(lowX)) + yOffset;		double highY1 = evaluateMean(new NumValue(highX)) + yOffset;				Point startPos1 = finder.findPoint(lowX, lowY1, null);		Point endPos1 = finder.findPoint(highX, highY1, null);				double lowY2 = evaluateMean(new NumValue(lowX)) - yOffset;		double highY2 = evaluateMean(new NumValue(highX)) - yOffset;				Point startPos2 = finder.findPoint(lowX, lowY2, null);		Point endPos2 = finder.findPoint(highX, highY2, null);				int x[] = {startPos1.x, endPos1.x, endPos2.x, startPos2.x};		int y[] = {startPos1.y, endPos1.y, endPos2.y, startPos2.y};				g.fillPolygon(x, y, 4);		g.drawLine(startPos1.x, startPos1.y, endPos1.x, endPos1.y);		g.drawLine(startPos2.x, startPos2.y, endPos2.x, endPos2.y);				g.setColor(meanColor);		drawMean(g, view, xAxis, yAxis);	}		public void setSDDrag(boolean sdDrag) {		this.sdDrag = sdDrag;	}		public void setFixedIntercept(boolean fixedIntercept) {		this.fixedIntercept = fixedIntercept;	}		public Point[] getHandles(DataView view, NumCatAxis xAxis, NumCatAxis yAxis) {		PositionFinder finder = new PositionFinder(view, xAxis, yAxis);		double xMin = xAxis.minOnAxis;		double xMax = xAxis.maxOnAxis;				int nPoints = 1;		if (sdDrag)			nPoints++;		if (!fixedIntercept)			nPoints++;				Point[] p = new Point[nPoints];		int index = 0;		if (!fixedIntercept)			p[index ++] = finder.findPoint(xMin, evaluateMean(xMin), null);		p[index ++] = finder.findPoint(xMax, evaluateMean(xMax), null);		if (sdDrag)  {			double xMiddle = (xMax + xMin) / 2;			p[index] = finder.findPoint(xMiddle, evaluateMean(xMiddle)																	+ 2.0 * evaluateSD().toDouble(), null);		}		return p;	}		public void setHandle(int index, double newValue, NumCatAxis xAxis) {		double x0 = xAxis.minOnAxis;		double x1 = xAxis.maxOnAxis;				int nPoints = 1;		if (sdDrag)			nPoints++;		if (!fixedIntercept)			nPoints++;				if (sdDrag && index == nPoints - 1) {			double xMiddle = (x1 + x0) / 2;			double yMiddle = evaluateMean(xMiddle);			s0.setValue(Math.abs(newValue - yMiddle) * 0.5);		}		else {			double y0 = evaluateMean(x0);			double y1 = evaluateMean(x1);			if (index == 0 && !fixedIntercept)				y0 = newValue;			else				y1 = newValue;			b1.setValue((y1 - y0) / (x1 - x0));			b0.setValue(y0 - b1.toDouble() * x0);		}	}		public double getLeverage(Value[] x) {		double xDiff = ((NumValue)x[0]).toDouble() - sx / n;		return 1.0 / n + xDiff * xDiff / sxx;	}}