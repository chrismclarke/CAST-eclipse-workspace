package models;import java.awt.*;import java.util.*;import dataView.*;import axis.*;public class QuadraticModel extends LinearModel {	private NumValue b2;		public QuadraticModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1,																	NumValue b2, NumValue s0, NumValue s1) {		super(name, data, xKey, b0, b1, s0, s1);		this.b2 = b2;	}		public QuadraticModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1,																					NumValue b2, NumValue s0) {		this(name, data, xKey, b0, b1, b2, s0, kZero);	}		public QuadraticModel(String name, DataSet data, String xKey, String params) {		this(name, data, xKey, kZero, kZero, kZero, kZero);		setParameters(params);	}		public QuadraticModel(String name, DataSet data, String xKey) {															//		only for situations where parameters															//		are set by LS immediately after		super(name, data, xKey);	}		public void setParameters(String params) {		StringTokenizer theParams = new StringTokenizer(params);				b0 = new NumValue(theParams.nextToken());		b1 = new NumValue(theParams.nextToken());		b2 = new NumValue(theParams.nextToken());		s0 = new NumValue(theParams.nextToken());		if (theParams.hasMoreTokens())			s1 = new NumValue(theParams.nextToken());	}		public void setParameters(NumValue b0, NumValue b1, NumValue b2) {		setParameters(b0, b1);		this.b2 = b2;	}		public void setLSParams(String yKey, int intDecs,													int slopeDecs, int curveDecs, int sdDecs) {//		LeastSquares lsCalc = new LeastSquares(4);		double[] r = initSsqMatrix(4);		int nObs = 0;				double dataRow[] = new double[4];		ValueEnumeration xe = ((NumVariable)data.getVariable(xKey[0])).values();		ValueEnumeration ye = ((NumVariable)data.getVariable(yKey)).values();		try {			while (xe.hasMoreValues() && ye.hasMoreValues()) {				double x = xe.nextDouble();				double y = ye.nextDouble();				if (!Double.isNaN(x) && !Double.isNaN(y)) {					dataRow[0] = 1.0;					dataRow[1] = x;					dataRow[2] = x * x;					dataRow[3] = y;//					lsCalc.addDataRow(dataRow, 1.0);					givenC(r, dataRow, 1.0);					nObs ++;				}			}//			double coeff[] = lsCalc.getCoefficients();			double coeff[] = bSub(r, 4, null);			b0 = new NumValue(coeff[0], intDecs);			b1 = new NumValue(coeff[1], slopeDecs);			b2 = new NumValue(coeff[2], curveDecs);			//			SsqComponent rss = lsCalc.getSsqComponent(3, 0);			SSComponent rss = ssComp(r, 4, nObs, 0);			s0 = new NumValue(Math.sqrt(rss.ssq / rss.df), sdDecs);		} catch (GivensException e) {			System.err.println(e);		}	}		public void updateLSParams(String yKey) {		int intDecs = (b0 == null) ? 0 : b0.decimals;		int slopeDecs = (b1 == null) ? 0 : b1.decimals;		int curveDecs = (b2 == null) ? 0 : b2.decimals;		int sdDecs = (s0 == null) ? 0 : s0.decimals;		setLSParams(yKey, intDecs, slopeDecs, curveDecs, sdDecs);	}		public void setLSLinearParams(String yKey, int intDecs, int slopeDecs, int curveDecs, int sdDecs) {		super.setLSParams(yKey, intDecs, slopeDecs, sdDecs);		b2 = new NumValue(0.0, curveDecs);	}		public void setCurvature(NumValue b2) {		this.b2 = b2;	}		public void setCurvature(double b2Value) {		b2.setValue(b2Value);	}		public NumValue getCurvature() {		return b2;	}		protected boolean positiveSlopeOnRight(double x) {		double slope = b1.toDouble() + 2.0 * b2.toDouble() * x;		return (slope > 0.0) || (slope == 0.0 && b2.toDouble() > 0.0);	}		protected boolean positiveCurvature() {		return b2.toDouble() > 0.0;	}		public double evaluateMean(double x) {		return b0.toDouble() + x * (b1.toDouble() + x * b2.toDouble());	}		protected double inverseEvaluate(double y, boolean lowNotHigh) {		if (b2.toDouble() == 0.0)			return super.inverseEvaluate(y, lowNotHigh);		else {			double constCoeff = b0.toDouble() - y;			double rootTerm = Math.sqrt(b1.toDouble() * b1.toDouble() - 4.0 * constCoeff * b2.toDouble());			double xA = (-b1.toDouble() + rootTerm)/(2.0 * b2.toDouble());			double xB = (-b1.toDouble() - rootTerm)/(2.0 * b2.toDouble());			if (lowNotHigh == (xA <= xB))				return xA;			else				return xB;		}	}		public void drawMean(Graphics g, DataView view, NumCatAxis xAxis, NumCatAxis yAxis) {		if (b2.toDouble() == 0.0)			super.drawMean(g, view, xAxis, yAxis);		else {			PositionFinder finder = new PositionFinder(view, xAxis, yAxis);			double xMinMax = -b1.toDouble()/(2.0 * b2.toDouble());			double xMin = finder.xMin;			double xMax = finder.xMax;			if (xMinMax <= xMin || xMinMax >= xMax)				drawMonotonic(xMin, xMax, g, finder);//				drawSegment(xMin, xMax, evaluateMean(xMin), evaluateMean(xMax), g, finder);			else {				drawMonotonic(xMin, xMinMax, g, finder);				drawMonotonic(xMinMax, xMax, g, finder);//				drawSegment(xMin, xMinMax, evaluateMean(xMin), evaluateMean(xMinMax), g, finder);//				drawSegment(xMinMax, xMax, evaluateMean(xMinMax), evaluateMean(xMax), g, finder);			}		}	}		public void drawModel(Graphics g, DataView view, NumCatAxis xAxis,											NumCatAxis yAxis, Color fillColor, Color meanColor) {			//		Not implemented	}		public Point[] getHandles(DataView view, NumCatAxis xAxis, NumCatAxis yAxis) {		PositionFinder finder = new PositionFinder(view, xAxis, yAxis);		double xMin = xAxis.minOnAxis;		double xMax = xAxis.maxOnAxis;		double xMid = (xMin + xMax) * 0.5;		Point[] p = new Point[3];			p[0] = finder.findPoint(xMin, evaluateMean(xMin), null);			p[1] = finder.findPoint(xMid, evaluateMean(xMid), null);			p[2] = finder.findPoint(xMax, evaluateMean(xMax), null);		return p;	}		public void setHandle(int index, double newValue, NumCatAxis xAxis) {		double x0 = xAxis.minOnAxis;		double x2 = xAxis.maxOnAxis;		double x1 = 0.5 * (x0 + x2);;		double y0 = evaluateMean(x0);		double y1 = evaluateMean(x1);		double y2 = evaluateMean(x2);		switch (index) {			case 0:				y0 = newValue;				break;			case 1:				y1 = newValue;				break;			case 2:				y2 = newValue;				break;			default:				;		}		b2.setValue(((y1 - y0) / (x1-x0) - (y2 - y1) / (x2-x1)) / (x0 - x2));		b1.setValue((y1 - y0) / (x1 - x0) - b2.toDouble() * (x0 + x1));		b0.setValue(y0 - x0 * (b1.toDouble() + x0 * b2.toDouble()));	}}