package exerciseNormal;import dataView.*;import distn.*;//import exerciseNormalProg.*;public class IntervalLimits implements IntervalConstants {	public NumValue endVal, startVal;	public int questionType;		public IntervalLimits(double start, double end, int decimals, int questionType) {		if (!Double.isInfinite(end))			endVal = new NumValue(end, decimals);		if (!Double.isInfinite(start))			startVal = new NumValue(start, decimals);		this.questionType = questionType;	}		public String toString() {		String startString = (startVal == null) ? null : startVal.toString();		String endString = (endVal == null) ? null : endVal.toString();		switch (questionType) {			case LESS_THAN:				return "less than " + endString;			case LESS_THAN_SIMPLE:				return endString;			case GREATER_THAN:				return "more than " + startString;			case GREATER_THAN_SIMPLE:				return startString;			case BETWEEN:				return "between " + startString + " and " + endString;			case OUTSIDE:				return "outside the range " + endString + " to " + startString;			case WITHIN_ZERO:				return "within " + endString;			case OUTSIDE_ZERO:				return "more than " + endString;		}		return null;	}		public String areaAnswerString() {		String startString = (startVal == null) ? null : startVal.toString();		String endString = (endVal == null) ? null : endVal.toString();		switch (questionType) {			case LESS_THAN:			case LESS_THAN_SIMPLE:				return "to the left of " + endString;			case GREATER_THAN:			case GREATER_THAN_SIMPLE:				return "to the right of " + startString;			case BETWEEN:				return "between " + startString + " and " + endString;			case OUTSIDE:				return "to the left of " + endString + " plus the area to the right of " + startString;			case WITHIN_ZERO:				return "within " + endString + " of zero";			case OUTSIDE_ZERO:				return "further than " + endString + " from zero";		}		return null;	}		public String generalAnswerString() {		String startString = (startVal == null) ? null : startVal.toString();		String endString = (endVal == null) ? null : endVal.toString();		switch (questionType) {			case LESS_THAN:			case LESS_THAN_SIMPLE:				return "less than " + endString;			case GREATER_THAN:			case GREATER_THAN_SIMPLE:				return "more than " + startString;			case BETWEEN:				return "between " + startString + " and " + endString;			case OUTSIDE:				return "outside the range " + endString + " to " + startString;			case WITHIN_ZERO:				return "within " + endString + " of zero";			case OUTSIDE_ZERO:				return "more than " + endString + " from zero";		}		return null;	}		public IntervalLimits translateToZ(ContinDistnVariable distn) {		double mean = distn.getMean().toDouble();		double sd = distn.getSD().toDouble();		double startX, endX;				if (questionType == WITHIN_ZERO) {			startX = -endVal.toDouble();			endX = endVal.toDouble();		}		else if (questionType == OUTSIDE_ZERO) {			startX = endVal.toDouble();			endX = -endVal.toDouble();		}		else {			startX = (startVal == null) ? Double.NEGATIVE_INFINITY : startVal.toDouble();			endX = (endVal == null) ? Double.NEGATIVE_INFINITY : endVal.toDouble();		}				double startZ = (startX - mean) / sd;		double endZ = (endX - mean) / sd;		return new IntervalLimits(startZ, endZ, 3, questionType);	}		public boolean equals(Object obj) {		if (obj == null || !(obj instanceof IntervalLimits))			return false;					IntervalLimits objValue = (IntervalLimits)obj;		return startVal.equals(objValue.startVal) && endVal.equals(objValue.endVal);	}}