package matrix;import java.awt.*;import dataView.*;public class FactorTerm extends VariateTerm {	static final private int kLevelGap = 12;	static final private int kGenericRowGap = 1;		private String effectString;		private XApplet applet;	private int zeroWidth;		private boolean hasLevel[];		public FactorTerm(DataSet data, String key, int baseLevel, boolean varNameHeading,														String coeffBase, int startSubscript, Color termColor, XApplet applet) {		super(data, key, varNameHeading, coeffBase, startSubscript, null, termColor);		this.applet = applet;		CatVariable yVar = (CatVariable)data.getVariable(key);		hasLevel = new boolean[yVar.noOfCategories()];		setBaselineLevel(baseLevel);	}		public FactorTerm(DataSet data, String key, boolean[] allowedTerm, boolean varNameHeading,																String coeffBase, int startSubscript, Color termColor, XApplet applet) {		super(data, key, varNameHeading, coeffBase, startSubscript, null, termColor);		this.applet = applet;		hasLevel = allowedTerm;	}		public void setEffectString(String effectString) {		//	to make it "interaction" for cat-cat interaction variable		this.effectString = effectString;	}		private void setupEffectString() {		if (effectString == null)			effectString = applet.translate("effect");	}		public void setBaselineLevel(int baseLevel) {		// -1 for no base level		for (int i=0 ; i<hasLevel.length ; i++)			hasLevel[i] = i != baseLevel;	}		public int getBaselineLevel() {		for (int i=0 ; i<hasLevel.length ; i++)			if (!hasLevel[i])				return i;		return -1;	}		public boolean usesLevel(int i) {		return hasLevel[i];	}		protected void doInitialisation(Graphics g) {		zeroWidth = g.getFontMetrics().stringWidth("0");	}		public int noOfParameters() {		int nParams = 0;		for (int i=0 ; i<hasLevel.length ; i++)			if (hasLevel[i])				nParams ++;		return nParams;	}			public void drawParameter(int paramIndex, int horiz, int baseline, Graphics g) {		int drawIndex = 0;		for (int i=0 ; i<hasLevel.length ; i++)			if (hasLevel[i]) {				if (drawIndex == paramIndex) {					super.drawParameter(i, horiz, baseline, g);					return;				}				else					drawIndex ++;			}	}	//----------------------------------		public Dimension matrixHeadingSize(Graphics g) {		Dimension dim = super.matrixHeadingSize(g);		if (dim != null)			dim.height += kCurlyBracketHeight;		return dim;	}		public void drawMatrixHeading(int center, int bottom, Graphics g) {		if (varNameHeading) {			drawCurlyBracket(center, matrixColumnWidth(g) + 8, bottom, g);						super.drawMatrixHeading(center, bottom - kCurlyBracketHeight, g);		}	}	//----------------------------------		public int matrixColumnWidth(Graphics g) {		initialise(g);				int nColumns = noOfParameters();				return nColumns * zeroWidth + (nColumns - 1) * kLevelGap;	}		public void drawMatrixValue(int row, int colRight, int baseline, Graphics g) {		CatVariable yVar = (CatVariable)data.getVariable(key);		int cat = yVar.getItemCategory(row);		int noOfCats = hasLevel.length;				for (int i=noOfCats-1 ; i>=0 ; i--)			if (hasLevel[i]) {				g.drawString(i == cat ? "1" : "0", colRight - zeroWidth, baseline);				colRight -= (zeroWidth + kLevelGap);			}	}	//----------------------------------		public int maxLinearPartWidth(Graphics g, boolean withPlus) {		initialise(g);		int paramWidth = maxParamWidth(g);		int plusWid = withPlus ? plusWidth(g) : 0;				return noOfParameters() * (paramWidth + plusWid);	}		public void drawLinearPartString(int row, int horiz, int baseline,																									boolean withPlus, Graphics g) {		initialise(g);				CatVariable yVar = (CatVariable)data.getVariable(key);				int cat = yVar.getItemCategory(row);		int usedIndex = 0;				if (hasLevel[cat]) {			int subColWidth = maxParamWidth(g);			if (withPlus)				subColWidth += plusWidth(g);			for (int i=0 ; i<cat ; i++)				if (hasLevel[i]) {					horiz += subColWidth;					usedIndex ++;				}			if (withPlus)				horiz = drawPlus(horiz, baseline, true, g);						drawParameter(usedIndex, horiz, baseline, g);		}	}		public void drawLinearPartString(Flags selection, int horiz, int baseline,																									boolean withPlus, Graphics g) {		CatVariable yVar = (CatVariable)data.getVariable(key);		int row = selection.findFirstSetFlag();		Value selectedY = yVar.valueAt(row);				ValueEnumeration ye = yVar.values();		FlagEnumeration fe = selection.getEnumeration();		while (ye.hasMoreValues() && fe.hasMoreFlags()) {			Value y = ye.nextValue();			boolean isSelected = fe.nextFlag();			if (isSelected && y != selectedY) {				selectedY = null;				break;			}		}				int linWidth = maxLinearPartWidth(g, withPlus);		int genericWidth = onlyGenericTermWidth(g, withPlus);		int overallWidth = Math.max(linWidth, genericWidth);//		System.out.println("linWidth = " + linWidth + ", genericWidth = " + genericWidth);		horiz += (overallWidth - linWidth) / 2;				if (selectedY == null)			g.drawString("+ ??", horiz, baseline);		else 			drawLinearPartString(row, horiz, baseline, withPlus, g);	}	//----------------------------------		public int getGenericTermHeight(Graphics g) {		FontMetrics fm = g.getFontMetrics();		return super.getGenericTermHeight(g) + fm.getAscent() + fm.getDescent() + kGenericRowGap;	}		private int onlyGenericTermWidth(Graphics g, boolean withPlus) {		setupEffectString();		FontMetrics fm = g.getFontMetrics();		int effectStringWidth = fm.stringWidth(effectString);		int varNameWidth = matrixHeadingSize(g).width;				int width = Math.max(effectStringWidth, varNameWidth);		if (withPlus)			width += plusWidth(g);		return width;	}		public int getGenericTermWidth(Graphics g, boolean withPlus) {		return Math.max(onlyGenericTermWidth(g, withPlus), maxLinearPartWidth(g, withPlus));	}		public void drawGenericTerm(int horiz, int baseline,																									boolean withPlus, Graphics g) {		setupEffectString();		int linWidth = maxLinearPartWidth(g, withPlus);		int genericWidth = onlyGenericTermWidth(g, withPlus);		int overallWidth = Math.max(linWidth, genericWidth);		horiz += (overallWidth - genericWidth) / 2;				g.setColor(getTermColor());		horiz = drawPlus(horiz, baseline, withPlus, g);				int varNameWidth = matrixHeadingSize(g).width;		FontMetrics fm = g.getFontMetrics();		int effectStringWidth = fm.stringWidth(effectString);				int center = horiz + getGenericTermWidth(g, false) / 2;				int halfLineOffset = (fm.getAscent() + fm.getDescent() + kGenericRowGap) / 2;				String varName = data.getVariable(key).name;		g.drawString(varName, center - varNameWidth / 2, baseline - halfLineOffset);		g.drawString(effectString, center - effectStringWidth / 2, baseline + halfLineOffset);	}}