package matrix;import java.awt.*;import dataView.*;public class VariateTerm extends ModelTerm {	static final protected int kTopBottomHeadingBorder = 2;	static final protected int kValueCoeffGap = 2;		protected DataSet data;	protected String key;	protected boolean varNameHeading;	protected String genericVarName;		protected int maxValueWidth;		private String headingString = null;		public VariateTerm(DataSet data, String key, boolean varNameHeading,							String coeffBase, int startSubscript, String genericVarName, Color termColor) {		super(coeffBase, startSubscript, termColor);		this.data = data;		this.key = key;		this.varNameHeading = varNameHeading;		this.genericVarName = genericVarName;	}		public void setHeadingString(String headingString) {		this.headingString = headingString;	}		protected void doInitialisation(Graphics g) {		super.doInitialisation(g);		Variable yVar = (Variable)data.getVariable(key);				maxValueWidth = yVar.getMaxWidth(g);	}		public String getGenericVarName() {		return genericVarName;	}	//----------------------------------	protected String getHeadingString() {		return (headingString == null) ? data.getVariable(key).name : headingString;	}		public Dimension matrixHeadingSize(Graphics g) {		initialise(g);		if (varNameHeading) {			String varName = getHeadingString();			FontMetrics fm = g.getFontMetrics();			int width = fm.stringWidth(varName);			int height = fm.getAscent() + fm.getDescent();						if (power > 1) {				width += powerWidth + 1;								int ascent = g.getFontMetrics().getAscent();				int superAscent = powerAscent(g);				if (superAscent > ascent)					height += superAscent - ascent;			}			return new Dimension(width, height + 2 * kTopBottomHeadingBorder);		}		else			return null;	}		public void drawMatrixHeading(int center, int bottom, Graphics g) {		initialise(g);		if (varNameHeading) {			FontMetrics fm = g.getFontMetrics();			String varName = getHeadingString();			int headingWidth = fm.stringWidth(varName);			int baseline = bottom - kTopBottomHeadingBorder - fm.getDescent();			int left = center - matrixHeadingSize(g).width / 2;			g.drawString(varName, left, baseline);			if (power > 1) {				int horiz = left + headingWidth;				drawPower(horiz, baseline, g);			}		}	}	//----------------------------------		public int matrixColumnWidth(Graphics g) {		initialise(g);		return maxValueWidth + powerWidth;	}		public void drawMatrixValue(int row, int colRight, int baseline, Graphics g) {		initialise(g);		colRight -= powerWidth;		Variable yVar = (Variable)data.getVariable(key);		Value y = yVar.valueAt(row);		y.drawLeft(g, colRight, baseline);		if (power > 1)			drawPower(colRight, baseline, g);	}	//----------------------------------		public int maxLinearPartWidth(Graphics g, boolean withPlus) {		int paramWidth = maxParamWidth(g);		if (paramWidth > 0)			paramWidth += kValueCoeffGap;		int width = super.maxLinearPartWidth(g, withPlus) + matrixColumnWidth(g) + paramWidth;		return width;	}		public void drawLinearPartString(int row, int horiz, int baseline,																									boolean withPlus, Graphics g) {		horiz = drawPlus(horiz, baseline, withPlus, g);		int valueRight = horiz + matrixColumnWidth(g);				drawMatrixValue(row, valueRight, baseline, g);		horiz = valueRight + kValueCoeffGap;				drawParameter(0, horiz, baseline, g);	}		public void drawLinearPartString(Flags selection, int horiz, int baseline,																									boolean withPlus, Graphics g) {		int row = selection.findSingleSetFlag();		if (row >= 0)			drawLinearPartString(row, horiz, baseline, withPlus, g);		else			drawGenericTerm(horiz, baseline, withPlus,  g);	}	//----------------------------------		private int onlyGenericTermWidth(Graphics g, boolean withPlus) {		int width = maxParamWidth(g);		if (width > 0)			width += kValueCoeffGap;		width += g.getFontMetrics().stringWidth(genericVarName);					if (withPlus)			width += plusWidth(g);		return width;	}		public int getGenericTermWidth(Graphics g, boolean withPlus) {		return Math.max(onlyGenericTermWidth(g, withPlus), maxLinearPartWidth(g, withPlus));	}		public void drawGenericTerm(int horiz, int baseline,																									boolean withPlus, Graphics g) {		int linWidth = maxLinearPartWidth(g, withPlus);		int genericWidth = onlyGenericTermWidth(g, withPlus);		int overallWidth = Math.max(linWidth, genericWidth);		horiz += (overallWidth - genericWidth) / 2;				g.setColor(getTermColor());		horiz = drawPlus(horiz, baseline, withPlus, g);				int paramWidth = maxParamWidth(g);		if (paramWidth > 0) {			drawParameter(0, horiz, baseline, g);			horiz += paramWidth + kValueCoeffGap;		}		g.drawString(genericVarName, horiz, baseline);		horiz += g.getFontMetrics().stringWidth(genericVarName);		if (power > 1)			drawPower(horiz, baseline, g);	}}