package distn;import java.util.*;import dataView.*;public class BinomialDistnVariable extends DiscreteDistnVariable {	public BinomialDistnVariable(String theName) {		super(theName);	}	private double p;	private int n, decimals;	private int previousX = -999;	private double previousProb = 1.0;		public void setParams(String s) {		if (s == null) {			p = 0.5;			n = 1;			decimals = 2;		}		else			try {				StringTokenizer st = new StringTokenizer(s);				n = Integer.parseInt(st.nextToken());				p = Double.parseDouble(st.nextToken());				if (p < 0.0 || p > 1.0)					throw new Exception();				if (st.hasMoreTokens())					decimals = Integer.parseInt(st.nextToken());				else					decimals = 2;			} catch (Exception e) {				System.err.println("Bad parameters for Binomial distn");			}		double meanVal = getMean().toDouble();		setMinSelection(meanVal);		setMaxSelection(meanVal);	}		public NumValue getMean() {		return new NumValue(n * p, decimals);	}		public NumValue getSD() {		return new NumValue(Math.sqrt(n * p * (1.0 - p)), decimals);	}		public void setProb(double p) {		this.p = p;		previousX = -999;	}		public void setCount(int n) {		this.n = n;		previousX = -999;	}		public double getProb() {		return p;	}		public int getCount() {		return n;	}		public double getProbFactor() {		return 1.0;	}		public double getMaxScaledProb() {		int xLow = (int)Math.round(Math.floor(n * p));		return Math.max(getScaledProb(xLow), getScaledProb(xLow + 1)) * 1.1;	}		public double getScaledProb(int x) {		if (x == previousX)			return previousProb;		else if (x == 0) {			previousX = 0;			previousProb = Math.pow(1.0 - p, n);			return previousProb;		}		else if (x < 0 || x > n)			return 0.0;		else if (x == previousX + 1 && previousProb > 0.0) {			previousX ++;			previousProb *= (n - x + 1) * p / x / (1.0 - p);			return previousProb;		}		else {			previousX = x;						double pq = p * (1.0 - p);			if (x < n - x)				previousProb = Math.pow(1.0 - p, n - 2 * x);			else				previousProb = Math.pow(p, 2 * x - n);						int x1 = Math.min(x, n - x);			for (int i=0 ; i<x1 ; i++)				previousProb *= ((double)(n-i)) / (i+1) * pq;			//			previousProb = Math.pow(p, x) * Math.pow(1.0 - p, n - x);//			int x1 = Math.min(x, n - x);//			for (int i=0 ; i<x1 ; i++)//				previousProb *= ((double)(n-i)) / (i+1);			return previousProb;		}	}			public double getCumulativeProb(double v) {		if (v < 0.0)			return 0.0;		else if (v > n)			return 1.0;		else																	//		slightly faster than generic method																	//		(uses normal approx for large n)		return BinomialTable.cumulative((int)Math.round(Math.floor(v)), n, p);	}	}