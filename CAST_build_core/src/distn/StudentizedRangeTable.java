package distn;public class StudentizedRangeTable {		static public double cumulative(double q, double df, double nMeans) {		return ptukey(q, 1, nMeans, df);	}		static public double quantile(double p, double df, double nMeans) {		return qtukey(p, 1, nMeans, df);	}//	The following code was translated to Java from the R routines ptukey() and qtukey()static final private int nleg = 12;static final private int ihalf = 6;static final private double M_1_SQRT_2PI = 1.0 / Math.sqrt(2 * Math.PI);static final private double C1 = -30.;static final private double C2 = -50.;static final private double C3 = 60.;static final private double bb   = 8.;static final private double wlar = 3.;static final private double wincr1 = 2.;static final private double wincr2 = 3.;static final private double xleg[] = {			0.981560634246719250690549090149,			0.904117256370474856678465866119,			0.769902674194304687036893833213,			0.587317954286617447296702418941,			0.367831498998180193752691536644,			0.125233408511468915472441369464};			static final private double aleg[] = {			0.047175336386511827194615961485,			0.106939325995318430960254718194,			0.160078328543346226334652529543,			0.203167426723065921749064455810,			0.233492536538354808760849898925,			0.249147045813402785000562436043};static private double wprob(double w, double rr, double cc) {	double a, ac, pr_w, b, binc, blb, bub, c, cc1, einsum, elsum,													pminus, pplus, qexpo, qsqz, rinsum, wi, wincr, xx;	int j, jj;	qsqz = w * 0.5;	if (qsqz >= bb)		return 1.0;//	pr_w = 2 * pnorm(qsqz, 0.,1., 1,0) - 1.;	pr_w = 2 * NormalTable.alNorm(qsqz, false) - 1.0;	if (pr_w >= Math.exp(C2 / cc))		pr_w = Math.pow(pr_w, cc);	else		pr_w = 0.0;	if (w > wlar)		wincr = wincr1;	else		wincr = wincr2;	blb = qsqz;	binc = (bb - qsqz) / wincr;	bub = blb + binc;	einsum = 0.0;	cc1 = cc - 1.0;	for (wi = 1; wi <= wincr; wi++) {		elsum = 0.0;		a = 0.5 * (bub + blb);		b = 0.5 * (bub - blb);		for (jj = 1; jj <= nleg; jj++) {			if (ihalf < jj) {				j = (nleg - jj) + 1;				xx = xleg[j-1];			}			else {				j = jj;				xx = -xleg[j-1];			}			c = b * xx;			ac = a + c;			qexpo = ac * ac;			if (qexpo > C3)				break;			pplus = 2 * NormalTable.alNorm(ac, false);			pminus= 2 * NormalTable.alNorm(ac - w,  false);			rinsum = (pplus * 0.5) - (pminus * 0.5);			if (rinsum >= Math.exp(C1 / cc1)) {				rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);				elsum += rinsum;			}		}		elsum *= (((2.0 * b) * cc) * M_1_SQRT_2PI);		einsum += elsum;		blb = bub;		bub += binc;	}	pr_w = einsum + pr_w;	if (pr_w <= Math.exp(C1 / rr))		return 0.;	pr_w = Math.pow(pr_w, rr);	if (pr_w >= 1.0)		return 1.;	return pr_w;}static final private double M_LN2 = Math.log(2.0);static final private int nlegq = 16;static final private int ihalfq	= 8;static final private double eps1 = -30.0;static final private double eps2 = 1.0e-14;static final private double dhaf  = 100.0;static final private double dquar = 800.0;static final private double deigh = 5000.0;static final private double dlarg = 25000.0;static final private double ulen1 = 1.0;static final private double ulen2 = 0.5;static final private double ulen3 = 0.25;static final private double ulen4 = 0.125;static final private double xlegq[] = {					0.989400934991649932596154173450,					0.944575023073232576077988415535,					0.865631202387831743880467897712,					0.755404408355003033895101194847,					0.617876244402643748446671764049,					0.458016777657227386342419442984,					0.281603550779258913230460501460,					0.950125098376374401853193354250e-1};static final private double alegq[] = {					0.271524594117540948517805724560e-1,					0.622535239386478928628438369944e-1,					0.951585116824927848099251076022e-1,					0.124628971255533872052476282192,					0.149595988816576732081501730547,					0.169156519395002538189312079030,					0.182603415044923588866763667969,					0.189450610455068496285396723208};static private double ptukey(double q, double rr, double cc, double df) {	double ans, f2, f21, f2lf, ff4, otsum, qsqz, rotsum, t1, twa1, ulen, wprb;	int i, j, jj;	if (q <= 0)		return 0.0;			//	R_DT_0;	if (df < 2 || rr < 1 || cc < 2)		return Double.NaN;			//	ML_ERR_return_NAN;	if (df > dlarg)		return wprob(q, rr, cc);				//	R_DT_val(wprob(q, rr, cc));	f2 = df * 0.5;    /* lgammafn(u) = log(gamma(u)) */	f2lf = ((f2 * Math.log(df)) - (df * M_LN2)) - FTable.aLoGam(f2);	f21 = f2 - 1.0;	ff4 = df * 0.25;	if (df <= dhaf)		ulen = ulen1;	else if (df <= dquar)		ulen = ulen2;	else if (df <= deigh)		ulen = ulen3;	else		ulen = ulen4;	f2lf += Math.log(ulen);	ans = 0.0;	otsum = 0.0;		for (i = 1; i <= 50; i++) {		otsum = 0.0;		twa1 = (2 * i - 1) * ulen;		for (jj = 1; jj <= nlegq; jj++) {			if (ihalfq < jj) {				j = jj - ihalfq - 1;				t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))															- (((xlegq[j] * ulen) + twa1) * ff4);			}			else {				j = jj - 1;				t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))															+ (((xlegq[j] * ulen) - twa1) * ff4);			}			if (t1 >= eps1) {				if (ihalfq < jj) {					qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);				}				else {					qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);				}				wprb = wprob(qsqz, rr, cc);				rotsum = (wprb * alegq[j]) * Math.exp(t1);				otsum += rotsum;			}		}		if (i * ulen >= 1.0 && otsum <= eps2)	    break;		ans += otsum;	}	if(otsum > eps2) { /* not converged */		return Double.NaN;	}	if (ans > 1.)		ans = 1.;			return ans;				//R_DT_val(ans);}static final private double p0 = 0.322232421088;static final private double q0 = 0.993484626060e-01;static final private double p1 = -1.0;static final private double q1 = 0.588581570495;static final private double p2 = -0.342242088547;static final private double q2 = 0.531103462366;static final private double p3 = -0.204231210125;static final private double q3 = 0.103537752850;static final private double p4 = -0.453642210148e-04;static final private double q4 = 0.38560700634e-02;static final private double c1 = 0.8832;static final private double c2 = 0.2368;static final private double c3 = 1.214;static final private double c4 = 1.208;static final private double c5 = 1.4142;static final private double vmax = 120.0;static private double qinv(double p, double c, double v) {	double ps, q, t, yi;	ps = 0.5 - 0.5 * p;	yi = Math.sqrt(Math.log(1.0 / (ps * ps)));	t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)								/ (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);	if (v < vmax)		t += (t * t * t + t) / v / 4.0;	q = c1 - c2 * t;	if (v < vmax)		q += -c3 / v + c4 * t / v;	return t * (q * Math.log(c - 1.0) + c5);}static final private double eps = 0.0001;static final private int maxiter = 50;static private double qtukey(double p, double rr, double cc, double df)	{	double ans = 0.0, valx0, valx1, x0, x1, xabs;	int iter;	if (df < 2 || rr < 1 || cc < 2)		return Double.NaN;						// ML_ERR_return_NAN;//    R_Q_P01_boundaries(p, 0, ML_POSINF);//    p = R_DT_qIv(p); /* lower_tail,non-log "p" */	x0 = qinv(p, cc, df);	valx0 = ptukey(x0, rr, cc, df) - p;	if (valx0 > 0.0)		x1 = Math.max(0.0, x0 - 1.0);	else		x1 = x0 + 1.0;	valx1 = ptukey(x1, rr, cc, df) - p;	for(iter=1 ; iter < maxiter ; iter++) {		ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));		valx0 = valx1;		x0 = x1;		if (ans < 0.0) {			ans = 0.0;			valx1 = -p;		}		valx1 = ptukey(ans, rr, cc, df) - p;		x1 = ans;		xabs = Math.abs(x1 - x0);		if (xabs < eps)			return ans;	}						//		ML_ERROR(ME_NOCONV, "qtukey");	 return Double.NaN;}	}