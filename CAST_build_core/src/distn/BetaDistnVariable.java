package distn;import java.util.*;import dataView.*;public class BetaDistnVariable extends ContinDistnVariable {		private NumValue alpha = new NumValue(1.0, 0);	private NumValue beta = new NumValue(1.0, 0);		private int meanDecimals = 0;	private int sdDecimals = 0;	private double logConst = 1;		// log(gamma(a + b)) - log(gamma(a)) - log(gamma(b))		public BetaDistnVariable(String theName) {		super(theName);	}		public void setParams(String s) {		if (s == null) {			alpha = new NumValue(1.0, 0);			beta = new NumValue(1.0, 0);		}		else			try {				StringTokenizer params = new StringTokenizer(s);				alpha = new NumValue(params.nextToken());				if (alpha.toDouble() <= 0.0)					throw new Exception();							beta = new NumValue(params.nextToken());				if (beta.toDouble() <= 0.0)					throw new Exception();			} catch (Exception e) {				System.err.println("Bad parameters for beta distn");			}		double meanVal = getMean().toDouble();		setLogConst();		setMinSelection(meanVal);		setMaxSelection(meanVal);	}		public void setMeanSdDecimals(int meanDecimals, int sdDecimals) {		this.meanDecimals = meanDecimals;		this.sdDecimals = sdDecimals;	}		public NumValue getMean() {		double a = alpha.toDouble();		double b = beta.toDouble();		return new NumValue(a / (a + b), meanDecimals);	}		public NumValue getSD() {		double a = alpha.toDouble();		double b = beta.toDouble();		return new NumValue(a * b / ((a + b) * (a + b) * (a + b + 1)), sdDecimals);	}		public NumValue getAlpha() {		return alpha;	}		public NumValue getBeta() {		return beta;	}		public void setAlpha(double newAlpha) {		alpha.setValue(newAlpha);		setLogConst();	}		public void setBeta(double newBeta) {		beta.setValue(newBeta);		setLogConst();	}		private void setLogConst() {		double a = alpha.toDouble();		double b = beta.toDouble();		logConst = GammaDistnVariable.aLoGam(a + b) - GammaDistnVariable.aLoGam(a) - GammaDistnVariable.aLoGam(b);	}		public double getDensityFactor() {		return 1.0;	}		public double getMaxScaledDensity() {		double a = alpha.toDouble();		double b = beta.toDouble();		if (a < 1 || b < 1)			return Double.POSITIVE_INFINITY;		else if (a == 1 && b == 1)			return 1.0;		else {			double mode = (a - 1) / (a + b - 2);			if (Double.isNaN(mode))				mode = 0.5;			return getScaledDensity(mode);		}	}		public double getScaledDensity(double x) {		double a = alpha.toDouble();		double b = beta.toDouble();		if (x < 0.0 || x > 1.0)			return 0.0;		else if (x == 0.0 && a < 1.0)			return Double.POSITIVE_INFINITY;		else if (x == 1.0 && b < 1.0)			return Double.POSITIVE_INFINITY;		else			return Math.exp(logConst + (a - 1) * Math.log(x) + (b - 1) * Math.log(1 - x));	}		public double getCumulativeProb(double v) {					//	not implemented yet		return Double.NaN;	}		public double getQuantile(double prob) {					//	not implemented yet		return Double.NaN;	}		public DistnInfo getDistnInfo() {					//	not implemented yet		return null;	}		public double xToZ(double x) {		return x;	}		public double zToX(double z) {		return z;	}}