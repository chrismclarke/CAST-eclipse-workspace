package distn;import java.util.*;import dataView.*;public class WeibullDistnVariable extends ContinDistnVariable {		private NumValue alpha = new NumValue(1.0, 0);	private NumValue lambda = new NumValue(1.0, 0);		private int meanDecimals = 0;	private int sdDecimals = 0;		public WeibullDistnVariable(String theName) {		super(theName);	}		public void setParams(String s) {		if (s == null) {			alpha = new NumValue(0.0, 0);			lambda = new NumValue(1.0, 0);		}		else			try {				StringTokenizer params = new StringTokenizer(s);				String alphaString = params.nextToken();				alpha = new NumValue(alphaString);				if (alpha.toDouble() <= 0.0)					throw new Exception();							String lambdaString = params.nextToken();				lambda = new NumValue(lambdaString);				if (lambda.toDouble() <= 0.0)					throw new Exception();							} catch (Exception e) {				System.err.println("Bad parameters for Weibull distn");			}		setMinSelection(-1);		setMaxSelection(-1);	}		public void setMeanSdDecimals(int meanDecimals, int sdDecimals) {		this.meanDecimals = meanDecimals;		this.sdDecimals = sdDecimals;	}		public NumValue getMean() {		double a = alpha.toDouble();		double l = lambda.toDouble();		double mean = GammaDistnVariable.aLoGam(1 + 1 / a) / l;		return new NumValue(mean, meanDecimals);	}		public NumValue getSD() {		double a = alpha.toDouble();		double l = lambda.toDouble();		double mean = GammaDistnVariable.aLoGam(1 + 1 / a) / l;		double var = GammaDistnVariable.aLoGam(1 + 2 / a) / (l * l) - mean * mean;		return new NumValue(Math.sqrt(var), sdDecimals);	}		public NumValue getAlpha() {		return alpha;	}		public NumValue getLambda() {		return lambda;	}		public void setAlpha(NumValue newAlpha) {		alpha = newAlpha;	}		public void setAlpha(double newAlpha) {		alpha.setValue(newAlpha);	}		public void setLambda(NumValue newLambda) {		lambda = newLambda;	}		public void setLambda(double newLambda) {		lambda.setValue(newLambda);	}		public double getDensityFactor() {		double a = alpha.toDouble();		double l = lambda.toDouble();		return a * Math.pow(l, a);	}		public double getMaxScaledDensity() {		if (alpha.toDouble() < 1.0)			return Double.POSITIVE_INFINITY;		else if (alpha.toDouble() == 1.0)			return lambda.toDouble() / getDensityFactor();		else {			double a = alpha.toDouble();			double l = lambda.toDouble();			double mode = Math.pow((a - 1) / a, 1 / a) / l;			return getScaledDensity(mode);		}	}		public double getScaledDensity(double x) {		double a = alpha.toDouble();		double l = lambda.toDouble();		if (x < 0.0)			return 0.0;		else if (x == 0.0) {			if (a < 1.0)				return Double.POSITIVE_INFINITY;			else if (a == 1.0)				return l / getDensityFactor();			else				return 0.0;		}		else			return Math.pow(x, a - 1) *  Math.exp(-Math.pow(l * x, a));	}		public double getCumulativeProb(double v) {		double a = alpha.toDouble();		double l = lambda.toDouble();		return 1 - Math.exp(-Math.pow(l * v, a));	}		public double getQuantile(double prob) {		double a = alpha.toDouble();		double l = lambda.toDouble();		return Math.pow(-Math.log(1 - prob), 1 / a) / l;	}		public DistnInfo getDistnInfo() {		return null;			//		still need to implement this	}		public double xToZ(double x) {		return x * lambda.toDouble();	}		public double zToX(double z) {		return z / lambda.toDouble();	}}