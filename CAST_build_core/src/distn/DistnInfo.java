package distn;abstract public class DistnInfo {	static final private double kMaxErrorProportion = 0.001;	static final private double kMinDensityProportion = 0.001;	static final private double kMinLinearProportion = 0.1;	static final private double kMinZProportion = 0.0001;		static final private int kMaxDistnPoints = 100;		private DistnPoints p0 = null;	private DistnPoints p1 = null;		private double maxError, minDensity;	private double minZLinearDist;			//	won't allow linear approx unless z's are this far apart		private boolean initialised = false;		private void initialise() {		if (initialised)			return;		maxError = maxDensity() * kMaxErrorProportion;		minDensity = maxDensity() * kMinDensityProportion;				if (isSymmetric() || zMin() >= zMode()) {//			double temp = zMode();			p1 = new DistnPoints(kMaxDistnPoints);			double zAtMode = zMode();			double dAtMode = getDensity(zAtMode);			p1.addPoint(zMode(), dAtMode);			if (Double.isInfinite(dAtMode)) {				zAtMode = zAtMode + (zMax() - zAtMode) * kMinZProportion;				dAtMode = getDensity(zAtMode);				maxError = dAtMode * kMaxErrorProportion;				minDensity = dAtMode * kMinDensityProportion;			}			minZLinearDist = Math.abs(zMax() - zAtMode) * kMinLinearProportion;			findDensities(p1, zAtMode, dAtMode, zMax(), getDensity(zMax()));			p1.compact();						if (isSymmetric())				p0 = new DistnPoints(p1, zMode());			else {				p0 = new DistnPoints(2);				p0.addPoint(zMode(), getDensity(zMode()));				p0.addPoint(zMode(), 0.0);			}		}		else {			p0 = new DistnPoints(kMaxDistnPoints);			p0.addPoint(zMode(), getDensity(zMode()));			minZLinearDist = Math.abs(zMode() - zMin()) * kMinLinearProportion;			findDensities(p0, zMode(), getDensity(zMode()), zMin(), getDensity(zMin()));			p0.compact();						if (zMax() > zMode()) {				p1 = new DistnPoints(kMaxDistnPoints);				p1.addPoint(zMode(), getDensity(zMode()));				minZLinearDist = Math.abs(zMax() - zMode()) * kMinLinearProportion;				findDensities(p1, zMode(), getDensity(zMode()), zMax(), getDensity(zMax()));				p1.compact();			}		}		initialised = true;	}		public DistnPoints getLowPoints() {		initialise();		return p0;	}		public DistnPoints getHighPoints() {		initialise();		return p1;	}		abstract public double zMin();	abstract public double zMax();	abstract public double zMode();	abstract public boolean isSymmetric();	abstract public double getDensity(double z);	abstract public boolean sameParams(ContinDistnVariable v);		public double maxDensity() {		return getDensity(zMode());	}		private void findDensities(DistnPoints p, double zLow, double dLow, double zHigh, double dHigh) {		double zMid = (zLow + zHigh) * 0.5;		double dMid = getDensity(zMid);		double dLinear = (dLow + dHigh) * 0.5;				if (dMid < minDensity)			findDensities(p, zLow, dLow, zMid, dMid);		else if (Math.abs(dMid - dLinear) < maxError && Math.abs(zHigh - zLow) < minZLinearDist)			p.addPoint(zHigh, dHigh);		else {			findDensities(p, zLow, dLow, zMid, dMid);			findDensities(p, zMid, dMid, zHigh, dHigh);		}	}		public double lookup(double z) {		initialise();		if (isSymmetric() || z >= zMode()) {			if (z < zMode())				z = 2.0 * zMode() - z;			for (int i=1 ; i<p1.z.length ; i++)				if (z <= p1.z[i])					return p1.d[i-1] + (p1.d[i] - p1.d[i-1]) * (z - p1.z[i-1]) / (p1.z[i] - p1.z[i-1]);			return 0.0;		}		else {			for (int i=1 ; i<p0.z.length ; i++)				if (z >= p0.z[i])					return p0.d[i-1] + (p0.d[i] - p0.d[i-1]) * (z - p0.z[i-1]) / (p0.z[i] - p0.z[i-1]);			return 0.0;		}	}}