package distn;public class FTable {		static public double cumulative(double x, double degree1, double degree2) {																		//		prob of less than or equal to x		if (x <= 0.0)			return 0.0;		else if (degree1 == 1.0)			return 1.0 - TTable.cumulative(-Math.sqrt(x), degree2) * 2.0;				double xBeta = degree1 * x;		xBeta = xBeta / (degree2 + xBeta);		double p = degree1 / 2.0;		double q = degree2 / 2.0;		double completeLogBeta = aLoGam(p) + aLoGam(q) - aLoGam(p + q);		double lowerProb = betaIn(xBeta, p, q, completeLogBeta);		return lowerProb;	}		static public double quantile(double prob, double degree1, double degree2) {		double p = degree1 / 2.0;		double q = degree2 / 2.0;		double completeLogBeta = aLoGam(p) + aLoGam(q) - aLoGam(p + q);//		double betaQuant = xInBta(p, q, completeLogBeta, 1.0 - prob);		double betaQuant = xInBta(p, q, completeLogBeta, prob);		return q / p * betaQuant / (1.0 - betaQuant);	}		static final private double  a1 = 0.918938533204673, a2 = 0.000595238095238,					a3 = 0.000793650793651, a4 = 0.002777777777778, a5 = 0.083333333333333;		static public double aLoGam (double x) {		if (x <= 0.0)			throw new RuntimeException("Bad parameter to aLoGam(): x = " + x);		else {			double y = x;			double f = 0.0;			if (y < 7.0) {				f = y;				y += 1.0;				while (y < 7.0) {					f *= y;					y ++;				}				f = -Math.log(f);			}			double z = 1.0 / (y * y);			return f + (y - 0.5) * Math.log(y) - y + a1 + (((-a2 * z + a3) * z - a4) * z + a5) / y;		}	}	static final private double betaAcu = 0.1e-7;	static public double betaIn (double x, double p, double q, double beta) {				//	AS63		if (p <= 0.0 || q <= 0.0)			throw new RuntimeException("Bad param to betaln(): p = " + p);		if (x < 0.0 || x > 1.0)			throw new RuntimeException("Bad param to betaln(): x = " + x);		if (x == 0.0 || x == 1.0)			return x;		double psq = p + q;		double cx = 1.0 - x;		double xx, pp, qq;		boolean index;		if (p < psq * x) {			xx = cx;			cx = x;			pp = q;			qq = p;			index = true;		}		else {			xx = x;			pp = p;			qq = q;			index = false;		}				double term = 1.0;		double ai = 1.0;		double result = 1.0;		int ns = (int)Math.round(Math.floor(qq + cx * psq));		double rx = xx / cx;				mainLoop: while (true) {			double temp = qq - ai;			if (ns == 0)				rx = xx;			while (true) {				term = term * temp * rx / (pp + ai);				result = result + term;				temp = Math.abs(term);				if (temp <= betaAcu && temp <= betaAcu * result)					break mainLoop;				ai ++;				ns --;				if (ns >= 0)					break;				temp = psq;				psq ++;			}		}		result *= Math.exp(pp * Math.log(xx) + (qq - 1.0) * Math.log(cx) - beta) / pp;		if (index)			return 1.0 - result;		else			return result;	}			static final private double xLnBetaAcu = 1.0e-14;	static final private double lower = 0.0001, upper = 0.9999, const1 = 2.30753,											const2 = 0.27061, const3 = 0.99229, const4 = 0.04481;		static public double xInBta (double p, double q, double beta, double alpha) {		if (p <= 0.0 || q <= 0.0)			throw new RuntimeException("Bad param to xInBta(): p = " + p);		if (alpha < 0.0 || alpha > 1.0)			throw new RuntimeException("Bad param to xInBta(): alpha = " + alpha);		if (alpha == 0.0 || alpha == 1.0)			return alpha;				double a, pp, qq;		boolean index;					if (alpha > 0.5) {			a = 1.0 - alpha;			pp = q;			qq = p;			index = true;		}	  else {			a = alpha;			pp = p;			qq = q;			index = false;		}				double r = Math.sqrt(-Math.log(a * a));		double y = r - (const1 + const2 * r) / (1.0 + (const3 + const4 * r) * r);		double result;		if (pp <= 1.0 || qq <= 1.0) {			r = qq * qq;			double t = 1.0 / (9.0 * qq);			t = r * Math.pow(1.0 - t + y * Math.sqrt(t), 3);			if (t > 0.0) {				t = (4.0 * pp + r - 2.0) / t;				if (t > 1.0)					result = 1.0 - 2.0 / (t + 1.0);				else					result = Math.exp((Math.log(a * pp) + beta) / pp);			}			else				result = 1.0 - Math.exp((Math.log((1.0 - a) * qq) + beta) / qq);		}		else {			r = (y * y - 3.0) / 6.0;			double s = 1.0 / (pp + pp - 1.0);			double t = 1.0 / (qq + qq - 1.0);			double h = 2.0 / (s + t);			double w = y * Math.sqrt(h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3.0 * h));			result = pp / (pp + qq * Math.exp(w + w));		}		r = 1.0 - pp;		double t = 1.0 - qq;		double yPrev = 0.0;		double sq = 1.0;		double prev = 1.0;				if (result < lower)			result = lower;		else if (result > upper)			result = upper;				mainLoop: while (true) {			y = betaIn(result, pp, qq, beta);			y = (y - a) * Math.exp(beta + r * Math.log(result) + t * Math.log(1.0 - result));			if (y * yPrev <= 0.0)				prev = sq;			double g = 1.0;						while (true) {				double adj = g * y;				sq = adj * adj;				if (sq < prev) {					double tx = result - adj;					if (tx >= 0.0 && tx <= 1.0) {						if (prev <= xLnBetaAcu || y * y <= xLnBetaAcu)							break mainLoop;						if (tx != 0.0 && tx != 1.0) {							if (tx == result)								break mainLoop;							result = tx;							yPrev = y;							break;						}					}				}				g /= 3.0;			}		}				if (index)			return 1.0 - result;		else			return result;	}}