package distn;import java.util.*;import dataView.*;public class GammaDistnVariable extends ContinDistnVariable {	static public double aLoGam(double x) {							//		package access for Poisson Variable		final double a1 = 0.918938533204673;		final double a2 = 0.000595238095238;		final double a3 = 0.000793650793651;		final double a4 = 0.002777777777778;		final double a5 = 0.083333333333333;			if (x <= 0.0)			throw new RuntimeException("bad parameter to aLoGam()");		double y = x;		double f = 0.0;		if (y < 7.0) {			f = y;			y += 1.0;			while (y < 7.0) {				f *= y;				y += 1.0;			}			f = -Math.log(f);		}		double z = 1.0 / (y * y);		return f + (y - 0.5) * Math.log(y) - y + a1 + (((-a2 * z + a3) * z - a4) * z + a5) / y;	}			static private double gammDS(double y, double p) {		final double e = 1.0E-6;				if (y <= 0.0 || p <= 0.0)			throw new RuntimeException("bad parameter to gammDS()");		double f = Math.exp(p * Math.log(y) - aLoGam(p + 1.0) - y);		if (f == 0.0)			throw new RuntimeException("bad parameter to gammDS()");		double c = 1.0;		double result = 1.0;		double a = p;		while (c / result > e) {			a += 1.0;			c *= (y / a);			result += c;		}		return result * f;	}		static protected double ppChi2(double p, double v, double g) {		final double aa = 0.6931471806;		final double e = 0.5E-6;		final double pMin = 0.000002;		final double pMax = 0.999998;		final double c1 = 0.01;		final double c2 = 0.222222;		final double c3 = 0.32;		final double c4 = 0.4;		final double c5 = 1.24;		final double c6 = 2.2;				if (p < pMin || p > pMax || v <= 0.0)			throw new RuntimeException("bad parameter to ppChi2()");				double xx = 0.5 * v;		double c = xx - 1.0;		double ch;		if (v < -c5 * Math.log(p)) {			ch = Math.pow(p * xx * Math.exp(g + xx * aa), 1.0 / xx);			if (ch < e)				return ch;		}		else if (v <= c3) {			final double c7 = 4.67;			final double c8 = 6.66;			final double c9 = 6.73;			final double c10 = 13.32;						ch = c4;			double a = Math.log(1.0 - p);			while (true) {				double q = ch;				double p1 = 1.0 + ch * (c7 + ch);				double p2 = ch * (c9 + ch * (c8 + ch));				double t = -0.5 + (c7 + 2.0 * ch) / p1 - (c9 + ch * (c10 + 3.0 * ch)) / p2;				ch = ch - (1.0 - Math.exp(a + g + 0.5 * ch + c * aa) * p2 / p1) / t;				if (Math.abs(q / ch - 1.0) <= c1)					break;			}		}		else {			double x = NormalDistnVariable.stdQuantile(p);			double p1 = c2 / v;			ch = v * Math.pow(x * Math.sqrt(p1) + 1.0 - p1, 3);			if (ch > c6 * v + 6.0)				ch = -2.0 * (Math.log(1.0 - p) - c * Math.log(0.5 * ch) + g);		}				final int maxIter = 20;		for (int i=0 ; i<maxIter ; i++) {			final double c11 = 60.0;			final double c12 = 70.0;			final double c13 = 84.0;			final double c14 = 105.0;			final double c15 = 120.0;			final double c16 = 127.0;			final double c17 = 140.0;			final double c18 = 175.0;			final double c19 = 210.0;			final double c20 = 252.0;			final double c21 = 264.0;			final double c22 = 294.0;			final double c23 = 346.0;			final double c24 = 420.0;			final double c25 = 462.0;			final double c26 = 606.0;			final double c27 = 672.0;			final double c28 = 707.0;			final double c29 = 735.0;			final double c30 = 889.0;			final double c31 = 932.0;			final double c32 = 966.0;			final double c33 = 1141.0;			final double c34 = 1182.0;			final double c35 = 1278.0;			final double c36 = 1740.0;			final double c37 = 2520.0;			final double c38 = 5040.0;						double q = ch;			double p1 = 0.5 * ch;			double p2 = p - gammDS(p1, xx);			double t = p2 * Math.exp(xx * aa + g + p1 - c * Math.log(ch));			double b = t / ch;			double a = 0.5 * t - b * c;			double s1 = (c19 + a * (c17 + a * (c14 + a * (c13 + a * (c12 + c11 * a))))) / c24;			double s2 = (c24 + a * (c29 + a * (c32 + a * (c33 + a * c35)))) / c37;			double s3 = (c19 + a * (c25 + a * (c28 + a * c31))) / c37;			double s4 = (c20 + a * (c27 + a * c34) + c * (c22 + a * (c30 + a * c36))) / c38;			double s5 = (c13 + a * c21 + c * (c18 + a * c26)) / c37;			double s6 = (c15 + c * (c23 + c * c16)) / c38;						ch += t * (1.0 + 0.5 * t * s1 - b * c * (s1 - b * (s2 - b * (s3 - b * (s4 - b * (s5 - b * s6))))));//			if (Math.abs(q / ch - 1.0) > e)			if (Math.abs(q / ch - 1.0) < e)				break;		}		return ch;	}		static public double gammaProb(double x, double sh) {		final double eps = 1.0E-6;		double logGammaPlus1 = aLoGam(sh) + Math.log(sh);				if (x <= 0.0 || sh <= 0.0)			return 0.0;		else {			double f = Math.exp(sh * Math.log(x) - logGammaPlus1 - x);			if (f == 0.0)				return 0.0;			else {				double c = 1.0;				double result = 1.0;				double a = sh;				while (c/result > eps) {					a += 1.0;					c *= (x / a);					result += c;				}				return result * f;			}		}	}		static public double gammaQuant(double prob, double sh) {		double gValue = aLoGam(sh);		return 0.5 * ppChi2(prob, 2.0 * sh, gValue);	}	//---------------------------------------------------------------------------------		private NumValue shape = new NumValue(1.0, 0);	private NumValue scale = new NumValue(1.0, 0);			//	inverse of lambda (& inverse of alpha)	private NumValue zeroPos = new NumValue(0.0, 0);		private int meanDecimals = 0;	private int sdDecimals = 0;	private double logConst = 1;		// log(beta / gamma(alpha))		public GammaDistnVariable(String theName) {		super(theName);	}		public void setParams(String s) {		if (s == null) {			shape = new NumValue(0.0, 0);			scale = new NumValue(1.0, 0);			zeroPos = new NumValue(0.0, 0);		}		else			try {				StringTokenizer params = new StringTokenizer(s);				String shapeString = params.nextToken();				shape = new NumValue(shapeString);				if (shape.toDouble() <= 0.0)					throw new Exception();							String scaleString = params.nextToken();				scale = new NumValue(scaleString);				if (scale.toDouble() <= 0.0)					throw new Exception();								if (params.hasMoreTokens()) {					String zeroString = params.nextToken();					zeroPos = new NumValue(zeroString);				}				else					zeroPos = new NumValue(0.0, 0);			} catch (Exception e) {				System.err.println("Bad parameters for gamma distn");			}		double meanVal = getMean().toDouble();		setLogConst();		setMinSelection(meanVal);		setMaxSelection(meanVal);	}		public void setMeanSdDecimals(int meanDecimals, int sdDecimals) {		this.meanDecimals = meanDecimals;		this.sdDecimals = sdDecimals;	}		public NumValue getMean() {		return new NumValue(zeroPos.toDouble() + scale.toDouble() * shape.toDouble(), meanDecimals);	}		public NumValue getSD() {		return new NumValue(scale.toDouble() * Math.sqrt(shape.toDouble()), sdDecimals);	}		public NumValue getShape() {		return shape;	}		public NumValue getScale() {		return scale;	}		public void setShape(double newShape) {		shape.setValue(newShape);		setLogConst();	}		public void setScale(double newScale) {		scale.setValue(newScale);		setLogConst();	}		public void setZeroPos(double newZeroPos) {		zeroPos.setValue(newZeroPos);	}		private void setLogConst() {		logConst = - Math.log(scale.toDouble()) - aLoGam(shape.toDouble());	}		public double getDensityFactor() {		return 1.0;	}		public double getMaxScaledDensity() {		double mode = Math.max(0, (shape.toDouble() - 1) * scale.toDouble());		return getScaledDensity(mode);	}		public double getScaledDensity(double x) {		double devn = (x - zeroPos.toDouble()) / scale.toDouble();		if (devn < 0.0)			return 0.0;		else if (devn == 0.0) {			if (shape.toDouble() < 1.0)				return Double.POSITIVE_INFINITY;			else if (shape.toDouble() == 1.0)				return 1.0 / scale.toDouble();			else				return 0.0;		}		else			return Math.exp(logConst + (shape.toDouble() - 1) * Math.log(devn) - devn);	}		public double getCumulativeProb(double v) {		return gammaProb((v - zeroPos.toDouble()) / scale.toDouble(), shape.toDouble());	}		public double getQuantile(double prob) {		return zeroPos.toDouble() + scale.toDouble() * gammaQuant(prob, shape.toDouble());	}		public DistnInfo getDistnInfo() {		return new GammaInfo(shape.toDouble());	}		public double xToZ(double x) {		return (x - zeroPos.toDouble()) / scale.toDouble();	}		public double zToX(double z) {		return z * scale.toDouble() + zeroPos.toDouble();	}}