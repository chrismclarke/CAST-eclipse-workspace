package distn;import dataView.*;public class TNCDistnVariable extends ContinDistnVariable {//****//**** Not debugged at all//****	static final double M_LN_SQRT_PI = Math.log(Math.PI) / 2;	static final double M_LN2 = Math.log(2.0);	static final double M_SQRT_2dPI = Math.sqrt(2.0 / Math.PI);		static final double DBL_EPSILON = 2.220446049250313E-16;	static final double DBL_MIN_EXP = -1021;	static final double DBL_MAX = Double.MAX_VALUE;		static public double cumProb(double t, double df, double ncp) {//**** FROM R CODE -- FUNCTION pnt()		/* note - itrmax and errmax may be changed to suit one's needs. */		int itrmax = 1000;		double errmax = 1.e-12;		if (df <= 0.0)			return Double.NaN;		if (ncp == 0.0)			return TTable.cumulative(t, df);		double del, tt;		boolean negdel;		if (t >= 0.) {			negdel = false;			tt = t;			del = ncp;		}		else {			negdel = true;			tt = -t;			del = -ncp;		}		if (df > 4e5 || del*del > 2 * M_LN2 * (-(DBL_MIN_EXP))) {				/*-- 2nd part: if del > 37.62, then p=0 below				FIXME: test should depend on `df', `tt' AND `del' ! */				/* Approx. from	 Abramowitz & Stegun 26.7.10 (p.949) */			double s = 1./(4.*df);			double z = (tt*(1. - s) - del) / Math.sqrt(1. + tt*tt*2.*s);			double lowProb = NormalTable.cumulative(z);			return negdel ? -lowProb : lowProb;    }    /* initialize twin series */    /* Guenther, J. (1978). Statist. Computn. Simuln. vol.6, 199. */		double x = t * t;		x = x / (x + df);			/* in [0,1) */		double tnc = 0.0;		if (x > 0.) {					/* <==>  t != 0 */			double lambda = del * del;			double p = .5 * Math.exp(-.5 * lambda);			if (p == 0.) {			/* underflow! */				/*========== really use an other algorithm for this case !!! */				//	ML_ERROR(ME_UNDERFLOW, "pnt");				//	ML_ERROR(ME_RANGE, "pnt"); /* |ncp| too large */				return Double.NEGATIVE_INFINITY;			}			double q = M_SQRT_2dPI * p * del;			double s = .5 - p;			double a = .5;			double b = .5 * df;			double rxb = Math.pow(1. - x, b); /* ~ 1 - b*x for tiny x */			double albeta = M_LN_SQRT_PI + FTable.aLoGam(b) - FTable.aLoGam(.5 + b);			double completeLogBeta = FTable.aLoGam(a) + FTable.aLoGam(b) - FTable.aLoGam(a + b);			double xodd = FTable.betaIn(x, a, b, completeLogBeta);			double godd = 2. * rxb * Math.exp(a * Math.log(x) - albeta);			tnc = b * x;			double xeven = (tnc < DBL_EPSILON) ? tnc : 1. - rxb;			double geven = tnc * rxb;			tnc = p * xodd + q * xeven;			/* repeat until convergence or iteration limit */			for(int it = 1; it <= itrmax; it++) {				a += 1.;				xodd  -= godd;				xeven -= geven;				godd  *= x * (a + b - 1.) / a;				geven *= x * (a + b - .5) / (a + .5);				p *= lambda / (2 * it);				q *= lambda / (2 * it + 1);				tnc += p * xodd + q * xeven;				s -= p;				/* R 2.4.0 added test for rounding error here. */				if (s < -1.e-10) /* happens e.g. for (t,df,ncp)=(40,10,38.5), after 799 it.*/					break;				if (s <= 0)					break;								double errbd = 2. * s * (xodd - godd);				if (errbd < errmax)					break;			/*convergence*/				if (it == itrmax)					/* non-convergence:*/					return Double.NaN;			}		}    tnc += NormalTable.cumulative(- del);		return negdel ? -tnc : tnc;	}		static final double accu = 1e-13;	static final double Eps = 1e-11;			/* must be > accu */		static public double quantile(double p, double df, double ncp) {//**** FROM R CODE -- FUNCTION qnt()		if (Double.isNaN(p) || Double.isNaN(df) || Double.isNaN(ncp))			return p + df + ncp;		if (Double.isInfinite(df))			return Double.NaN;		if (df <= 0.0)			return Double.NaN;    		if (ncp == 0.0)			return TTable.quantile(p, df);		/* Invert pnt(.) :		* 1. finding an upper and lower bound */		if(p > 1 - DBL_EPSILON)			return Double.POSITIVE_INFINITY;		double pp = Math.min(1 - DBL_EPSILON, p * (1 + Eps));		double ux;		for(ux = Math.max(1., ncp) ; ux<DBL_MAX && cumProb(ux, df, ncp)<pp ; ux *= 2)			;		pp = p * (1 - Eps);		double lx;		for(lx = Math.min(-1., -ncp) ; lx>-DBL_MAX && cumProb(lx, df, ncp)>pp ; lx *= 2)			;		/* 2. interval (lx,ux)  halving : */		double nx;		do {			nx = 0.5 * (lx + ux);			if (cumProb(nx, df, ncp) > p)				ux = nx;			else				lx = nx;    } while ((ux - lx) / Math.abs(nx) > accu);      return 0.5 * (lx + ux);	}	//---------------------------------------------------------------------------------	private double df;	private double ncp;		public TNCDistnVariable(String theName, double df, double ncp) {		super(theName);		this.df = df;		this.ncp = ncp;		setMinSelection(0.0);		setMaxSelection(0.0);	}		public void setParams(String s) {	}		public NumValue getMean() {		double basicMean = Math.sqrt(df / 2.0) * Math.exp(FTable.aLoGam((df - 1) / 2.0) - FTable.aLoGam(df / 2.0));		return new NumValue(basicMean * ncp, 0);	}		public NumValue getSD() {		double mean = getMean().toDouble();		return new NumValue(Math.sqrt(df * (1 + ncp * ncp) / (df - 2) - mean * mean), 3);	}		public double getDF() {		return df;	}		public void setDF(double df) {		this.df = df;	}		public double getNCP() {		return ncp;	}		public void setNCP(double ncp) {		this.ncp = ncp;	}		public double getDensityFactor() {		return 1.0;	}		public double getMaxScaledDensity() {		return 1.0;	}		public double getScaledDensity(double x) {//**** FROM R CODE -- FUNCTION dnt()				if (Double.isNaN(x) || Double.isNaN(df))			return x + df;    /* If non-positive df then error */		if (df <= 0.0)			return Double.NaN;    if (ncp == 0.0) {			/* from central t distn */			double densityFactor = Math.exp(GammaDistnVariable.aLoGam(0.5 * (df + 1))    								- GammaDistnVariable.aLoGam(0.5)										- GammaDistnVariable.aLoGam(0.5 * df)) / Math.sqrt(df);			double scaledDensity = Math.pow((1.0 + x * x / df), (-0.5 * (df + 1)));			return densityFactor * scaledDensity;		}		/* If infinite df then the density is identical to a			normal distribution with mean = ncp.  However, the formula			loses a lot of accuracy around df=1e9		*/		if (df > 1e8) {			double devn = x - ncp;			return Math.exp(-0.5 * devn * devn) / Math.sqrt(2.0 * Math.PI);		}		/* Do calculations on log scale to stabilize */		/* Consider two cases: x ~= 0 or not */		if (Math.abs(x) > Math.sqrt(df * DBL_EPSILON)) {			return Math.log(df) - Math.log(Math.abs(x)) +							Math.log(Math.abs(cumProb(x * Math.sqrt((df+2)/df), df+2, ncp) -							cumProb(x, df, ncp)));		/* FIXME: the above still suffers from cancellation (but not horribly) */		}		else {  /* x ~= 0 : -> same value as for  x = 0 */			return FTable.aLoGam((df+1)/2) - FTable.aLoGam(df/2)						- .5*(Math.log(Math.PI) + Math.log(df) + ncp*ncp);		}	}		public double getCumulativeProb(double v) {		return cumProb(v, df, ncp);	}		public double getQuantile(double prob) {		return quantile(prob, df, ncp);	}		public DistnInfo getDistnInfo() {//		if (true)			throw new RuntimeException("Noncentral T not yet fully implemented or debugged");//		return new TInfo(9999);		///		Not implemented yet	}		public double xToZ(double x) {		return x;	}		public double zToX(double z) {		return z;	}}