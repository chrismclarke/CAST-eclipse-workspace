package regn;import dataView.*;import axis.*;import models.*;public class PowerLinearModel extends LinearModel {	private NumCatAxis xAxis, yAxis;		private int intSigDigits, slopeSigDigits, sdSigDigits;	private int intMaxDecimals, slopeMaxDecimals, sdMaxDecimals;		public PowerLinearModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1,																																NumValue s0, NumCatAxis axis) {		super(name, data, xKey, b0, b1, s0, kZero);		if (axis instanceof VertAxis)			yAxis = axis;		else			xAxis = axis;	}		public PowerLinearModel(String name, DataSet data, String xKey, String params, NumCatAxis axis) {		super(name, data, xKey, params);		if (axis instanceof VertAxis)			yAxis = axis;		else			xAxis = axis;	}		public PowerLinearModel(String name, DataSet data, String xKey, NumCatAxis axis) {		//		only for situations where parameters																					//		are set by LS immediately after		super(name, data, xKey);		if (axis instanceof VertAxis)			yAxis = axis;		else			xAxis = axis;	}		public PowerLinearModel(String name, DataSet data, String xKey, NumCatAxis xAxis, NumCatAxis yAxis) {																	//		only for situations where parameters																	//		are set by LS immediately after		super(name, data, xKey);		this.xAxis = xAxis;		this.yAxis = yAxis;	}		private NumValue valueWithSigDigits(double val, int sigDigits, int maxDecimals) {		int decimals;		if (val == 0.0)			decimals = maxDecimals;		else {			decimals = sigDigits;			double temp = Math.abs(val);			while (temp >= 1.0) {				decimals --;				temp *= 0.1;			}			while (temp < 0.1) {				decimals ++;				temp *= 10.0;			}			decimals = Math.max(0, Math.min(decimals, maxDecimals));		}		return new NumValue(val, decimals);	}		public void setLSParams(String yKey, int intSigDigits,											int intMaxDecimals, int slopeSigDigits, int slopeMaxDecimals,											int sdSigDigits, int sdMaxDecimals) {		this.intSigDigits = intSigDigits;		this.slopeSigDigits = slopeSigDigits;		this.sdSigDigits = sdSigDigits;		this.intMaxDecimals = intMaxDecimals;		this.slopeMaxDecimals = slopeMaxDecimals;		this.sdMaxDecimals = sdMaxDecimals;				ValueEnumeration xe = ((NumVariable)data.getVariable(xKey[0])).values();		ValueEnumeration ye = ((NumVariable)data.getVariable(yKey)).values();		double sx = 0.0;		double sy = 0.0;		double sxx = 0.0;		double sxy = 0.0;		double syy = 0.0;		int n = 0;		while (xe.hasMoreValues() && ye.hasMoreValues()) {			double x = xe.nextDouble();			if (xAxis != null)				x = xAxis.transform(x);			double y = ye.nextDouble();			if (yAxis != null)				y = yAxis.transform(y);			if (!Double.isNaN(x) && !Double.isNaN(y)) {				sx += x;				sy += y;				sxx += x * x;				sxy += x * y;				syy += y * y;				n ++;			}		}		sxx -= sx * sx / n;		sxy -= sx * sy / n;		syy -= sy + sy / n;				b1 = valueWithSigDigits(sxy / sxx, slopeSigDigits, intMaxDecimals);		b0 = valueWithSigDigits((sy - sx * b1.toDouble()) / n, intSigDigits, slopeMaxDecimals);		s0 = valueWithSigDigits(Math.sqrt((syy - b1.toDouble() * sxy) / (n - 1)), sdSigDigits, sdMaxDecimals);	}		public void updateLSParams(String yKey) {		setLSParams(yKey, intSigDigits, intMaxDecimals, slopeSigDigits,								slopeMaxDecimals, sdSigDigits, sdMaxDecimals);	}		public double evaluateMean(double x) {		if (xAxis != null)			x = xAxis.transform(x);		double mean = b0.toDouble() + x * b1.toDouble();		if (yAxis != null)			mean = yAxis.inverseTransform(mean);		return mean;	}		public double evaluateUntransformedMean(double x) {		if (xAxis != null)			x = xAxis.transform(x);		return b0.toDouble() + x * b1.toDouble();	}		protected double inverseEvaluate(double y, boolean lowNotHigh) {											//		lowNotHigh only needed for quadratic		if (yAxis != null)			y = yAxis.transform(y);		double x = (y - b0.toDouble()) / b1.toDouble();		if (xAxis != null)			x = xAxis.inverseTransform(x);		return x;	}		public void setHandle(int index, double newValue, NumCatAxis xAxis) {		double x0 = xAxis.transform(xAxis.minOnAxis);		double x1 = xAxis.transform(xAxis.maxOnAxis);		double y0 = b0.toDouble() + x0 * b1.toDouble();		double y1 = b0.toDouble() + x1 * b1.toDouble();		switch (index) {			case 0:				y0 = newValue;				if (yAxis != null)					y0 = yAxis.transform(y0);				break;			case 1:				y1 = newValue;				if (yAxis != null)					y1 = yAxis.transform(y1);				break;			default:				;		}		b1.setValue((y1 - y0) / (x1 - x0));		b0.setValue(y0 - b1.toDouble() * x0);	}}