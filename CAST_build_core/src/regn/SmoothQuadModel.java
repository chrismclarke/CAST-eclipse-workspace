package regn;import java.awt.*;import java.util.*;import dataView.*;import axis.*;import models.*;public class SmoothQuadModel extends CoreModelVariable {	static final public NumValue kZero = new NumValue(0.0, 0);		static final private int kMaxHitDist = 9;		static final private int kFineSteps = 8;	static final private int kBlobSize = 3;		private double x0, xStep;	private double[] y;		private double a[], b[], c[];	//	static final private int kAnchorSize = 8;//	static final private int kArrowHeadSize = 3;//	//	private double x0, xStep;//	private double y[];//	//	static private void drawArrowHead(Graphics g, int x, int y, int dx, int dy) {//		g.drawLine(x, y, x + dx - dy, y + dy - dx);//		g.drawLine(x, y, x + dx + dy, y + dy + dx);//	}//	//	static public void drawBiHandle(Graphics g, Point p, boolean bold) {//		if (!bold) {//			g.setColor(Color.red);//			g.drawLine(p.x - kAnchorSize, p.y, p.x + kAnchorSize, p.y);//			g.drawLine(p.x, p.y - kAnchorSize, p.x, p.y + kAnchorSize);//			drawArrowHead(g, p.x - kAnchorSize - 1, p.y, kArrowHeadSize, 0);//			drawArrowHead(g, p.x + kAnchorSize + 1, p.y, -kArrowHeadSize, 0);//			drawArrowHead(g, p.x, p.y - kAnchorSize - 1, 0, kArrowHeadSize);//			drawArrowHead(g, p.x, p.y + kAnchorSize + 1, 0, -kArrowHeadSize);//		}//		g.setColor(bold ? Color.red : Color.black);//		g.drawOval(p.x - 2, p.y - 2, 5, 5);//	}		public SmoothQuadModel(String name, DataSet data, String xKey, double x0, double xStep,																			double[] y) {		super(name, data, xKey);		this.x0 = x0;		this.xStep = xStep;		this.y = y;		s0 = kZero;		setupModel();	}		public SmoothQuadModel(String name, DataSet data, String xKey, String modelString) {		super(name, data, xKey);		setParameters(modelString);		s0 = kZero;		setupModel();	}		public void setParameters(String s) {		StringTokenizer st = new StringTokenizer(s);		int nY = st.countTokens() - 2;				x0 = Double.parseDouble(st.nextToken());		xStep = Double.parseDouble(st.nextToken());				y = new double[nY];		for (int i=0 ; i<nY ; i++)			y[i] = Double.parseDouble(st.nextToken());	}		private void setupModel() {		a = new double[y.length - 2];		b = new double[y.length - 2];		c = new double[y.length - 2];				for (int i=0 ; i<a.length ; i++) {			a[i] = y[i + 1];			b[i] = (y[i + 2] - y[i]) * 0.5 / xStep;			c[i] = (y[i + 2] - 2 * y[i + 1] + y[i]) / (2 * xStep * xStep);		}	}		public int noOfParameters() {		return y.length;	}		public void updateLSParams(String yKey) {					//		still needs to be written	}		public double evaluateMean(double x) {		int lowIndex = (int)Math.round(Math.floor((x - x0) / xStep));		lowIndex = Math.max(1, Math.min(a.length, lowIndex));				int highIndex = (int)Math.round(Math.ceil((x - x0) / xStep));		highIndex = Math.max(1, Math.min(a.length, highIndex));				double lowDx = x - (x0 + lowIndex * xStep);				double lowFit = a[lowIndex - 1] + b[lowIndex - 1] * lowDx + c[lowIndex - 1] * lowDx * lowDx;				if (lowIndex == highIndex)			return lowFit;		else {			double highDx = x - (x0 + highIndex * xStep);			double highFit = a[highIndex - 1] + b[highIndex - 1] * highDx + c[highIndex - 1] * highDx * highDx;			double p = lowDx / xStep;			return p * highFit + (1.0 - p) * lowFit;		}	}		public double evaluateMean(Value[] x) {		return evaluateMean(((NumValue)x[0]).toDouble());	}		public void drawMean(Graphics g, DataView view, NumCatAxis xAxis,																							NumCatAxis yAxis) {		double lowX = xAxis.minOnAxis;		double highX = xAxis.maxOnAxis;		double xBorder = (highX - lowX) * 0.1;		lowX -= xBorder;		highX += xBorder;				int xPos = xAxis.numValToRawPosition(x0);		int yPos = yAxis.numValToRawPosition(evaluateMean(x0));		Point p0 = view.translateToScreen(xPos, yPos, null);		Point p1 = null;				for (int i=1 ; i<y.length ; i++)			for (int j=1 ; j<=kFineSteps ; j++) {				double x = x0 + (i - 1) * xStep + j * xStep / kFineSteps;				double y = evaluateMean(x);				xPos = xAxis.numValToRawPosition(x);				yPos = yAxis.numValToRawPosition(y);				p1 = view.translateToScreen(xPos, yPos, p1);				g.drawLine(p0.x, p0.y, p1.x, p1.y);								Point pTemp = p0; p0 = p1; p1 = pTemp;			}	}		public void drawHandles(Graphics g, DataView view, NumCatAxis xAxis, NumCatAxis yAxis,																															int selectedIndex) {		double x = x0;		g.setColor(Color.red);		for (int i=0 ; i<y.length ; i++) {			int xPos = xAxis.numValToRawPosition(x);			double y = evaluateMean(x);			int yPos = yAxis.numValToRawPosition(y);			Point p = view.translateToScreen(xPos, yPos, null);			if (i == selectedIndex)				g.fillOval(p.x - kBlobSize, p.y - kBlobSize, 2 * kBlobSize, 2 * kBlobSize);			else				g.drawOval(p.x - kBlobSize, p.y - kBlobSize, 2 * kBlobSize, 2 * kBlobSize);			x += xStep;		}	}		public VertDragPosInfo getSelectedHandle(Point p, NumCatAxis xAxis, NumCatAxis yAxis) {		double x = x0;		for (int i=0 ; i<y.length ; i++) {			int xPos = xAxis.numValToRawPosition(x);			double y = evaluateMean(x);			int yPos = yAxis.numValToRawPosition(y);			if (Math.abs(p.x - xPos) + Math.abs(p.y - yPos) < kMaxHitDist)				return new VertDragPosInfo(p.y, i, p.y - yPos);			x += xStep;		}		return null;	}		public void setHandle(int selectedIndex, double newY) {		y[selectedIndex] = newY;		setupModel();	}}