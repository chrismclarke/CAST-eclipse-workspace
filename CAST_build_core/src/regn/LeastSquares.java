package regn;public class LeastSquares {	private double r[];		//		first element of r is r[1], not r[0]									//		(from Fortran version)	private int nVars;	private int nObs = 0;		public LeastSquares(int nVars) {		this.nVars = nVars;		r = new double[(nVars * (nVars + 1)) / 2 + 1];				int ij = 0;		for (int i=1 ; i<=nVars ; i++) {			for (int j=1 ; j<i ; j++) {				ij ++;				r[ij] = 0.0;			}			ij ++;			r[ij] = -1.0;		}	}		public int addDataRow(double[] x, double v) {		final double eps = 0.000001;			int irUsed = (x.length * (x.length + 1)) / 2;		if (r.length < irUsed + 1)			return 1;		else if (v < 0.0)			return 2;				double vLocal = v;				int ii = 0;		for (int i=1 ; i<=nVars ; i++) {			ii = ii + i;			double xi = x[i-1];			if (xi != 0.0) {				double xi2 = xi * xi;				double cTemp = r[ii];				int ij = ii;				int iPlus = i + 1;								if (cTemp < 0.0) {					r[ii] = vLocal / xi2;					if (i == nVars)						break;					else {						for (int j=iPlus ; j<=nVars ; j++) {							ij += (j - 1);							r[ij] = x[j-1] / xi;						}						break;					}				}				if (cTemp <= 0.0)					for (int j=iPlus ; j<=nVars ; j++) {						ij += (j - 1);						double xj = x[j-1];						x[j-1] -= xi * r[ij];						if (Math.abs(x[j-1]) <= eps * Math.abs(xj))							x[j-1] = 0.0;					}				else {					double vNew = vLocal + cTemp * xi2;					double c = vLocal / vNew;					double s = cTemp * xi / vNew;					vLocal = vNew;					r[ii] = cTemp * c;					if (i == nVars) {						if (Math.abs(r[irUsed]) <= 0.0)							return 3;						else if (vLocal <= 0.0)							return -1;					}					else						for (int j=iPlus ; j<=nVars ; j++) {							ij += (j - 1);							double rTemp = c * r[ij] + s * x[j-1];							x[j-1] = x[j-1] - xi * r[ij];							r[ij] = rTemp;						}					}				}		}		nObs ++;		return 0;	}		public double[] getCoefficients(int iDep) {		int nxVars = iDep;		double coeff[] = new double[nxVars];		int ii = ((iDep + 1) * (iDep + 2)) / 2;		if (nxVars >= 1) {			int k = ii;			int nx = iDep + 1;			for (int i=1 ; i<=nxVars ; i++) {				ii -= nx;				k --;				double temp = r[k];//				if (r[ii] < 0.0)//					iFault := iFault - 1;				if (i > 1) {					int ij = ii;					for (int j=nx ; j<=nxVars ; j++) {						ij += (j-1);						temp -= (r[ij] * coeff[j-1]);					}				}				nx --;				coeff[nx - 1] = temp;			}		}		return coeff;	}		public double[] getCoefficients() {		return getCoefficients(nVars - 1);	}		public SsqComponent getSsqComponent(int iDep, int iComp) {		final double eps1 = 0.0;		double ssq = 0.0;		int idf = 0;				int irUsed = ((iDep + 1) * (iDep + 2)) / 2;//		if (iR < irUsed)//			iFault := 1;//		if ((iComp < 0) | (iComp >= iDep))//			iFault := iFault + 2;//		if (iFault = 0)			if (iComp == 0) {				int nxVars = iDep - 1;				idf = nObs - nxVars;				int ii = 0;				for (int i=1 ; i<=nxVars ; i++) {					ii += i;					if (r[ii] <= eps1)						idf ++;				}				if (r[irUsed] > eps1)					ssq = 1.0 / r[irUsed];			}			else {				int ii = (iComp * (iComp + 1)) / 2;				if (r[ii] > eps1) {					idf = 1;					int ij = irUsed - iDep + iComp;					ssq = r[ij] * r[ij] / r[ii];				}			}		return new SsqComponent(ssq, idf);	}		public double[] getVariance(int iDep) {		final double eps1 = 0.0;				int irUsed = ((iDep + 1) * (iDep + 2)) / 2;		double s[] = new double[irUsed];//		if (ir < irUsed | is < (irUsed - iDep))//			iFault := 1//		else {			int nxVars = iDep - 1;						int nCons = 0;			int ij = 0;			for (int i=1 ; i<=nxVars ; i++) {				int jj = 0;				int j = 0;				while (true) {					j ++;					ij ++;					jj += j;					if (j >= i) {						if (r[ij] <= eps1)							nCons ++;						break;					}					double sTemp = -r[ij];					int ik = ij;					int kj = jj;					int kMax = i - 1;					int kMin = j + 1;					for (int k=kMin ; k<=kMax ; k++) {						ik ++;						kj += (k - 1);						sTemp = sTemp - r[ik] * s[kj - 1];					}					 s[ij - 1] = sTemp;				}			}						int idf = nObs - nxVars + nCons;//			if (idf <= 0)//				iFault = 2;//			 else {//				iFault := 0;				double sigma = 0.0;				if (r[irUsed] > 0.0)					sigma = 1.0 / (r[irUsed] * idf);				int ii = 0;				for (int i=1 ; i<=nxVars ; i++) {					ii += i;					s[ii - 1] = sigma * r[ii];					if (r[ii] < 0.0)						s[ii - 1] = 0.0;				}								ii = 0;				ij = 0;				for (int i=1 ; i<=nxVars ; i++) {					ii += i;					for (int j=1 ; j<=i ; j++) {						int kk = ii;						ij ++;//						int ki = ij;						int kj = ii;						double sTemp = s[kk - 1];						if (i != j)							sTemp *= s[ij - 1];						int k = i;						while (true) {							k ++;							if (k > nxVars)								break;							kk += k;//							ki += (k - 1);							kj += (k - 1);							sTemp += s[kj - 1] * s[kj - 1];						}						s[ij - 1] = sTemp;					}				}//			}//		}		return s;	}		public int alias(double eps) {		int iFault = 0;		int nxVars = nVars - 1;				int nxMinU = nxVars - 1;		int ii = 0;		for (int i=1 ; i<=nxMinU ; i++) {			ii += i;			if (r[ii] == 0.0)				break;			int jj = ii;			int iPlus = i + 1;			for (int j=iPlus ; j<=nxVars ; j++) {				jj += j;				if (r[jj] != 0.0)					break;				int ik = jj - j + i;				int jk = jj;				double rij = r[ik];				r[ik] = 0.0;				int jPlus = j + 1;				for (int k=jPlus ; k<=nVars ; k++) {					ik += (k - 1);					jk += (k - 1);					r[ik] = r[ik] - rij * r[jk];				}			}		}		double eps2 = eps * eps;		double worksp[] = new double[nVars + 1];		ii = 0;		for (int i=1 ; i<=nxVars ; i++) {			ii += i;			worksp[i] = 0.0;						if (Math.abs(r[ii]) > 1.0) {				double diagi = 1.0 / r[ii];				int jj = 0;				int ji = ii - i;				int iMinus = i - 1;				for (int j=1 ; j<=iMinus ; j++) {					jj += j;					ji ++;					if (r[jj] > 0.0)						diagi += r[ji] * r[ji] / r[jj];				}				if (1.0 / Math.abs(r[ii]) <= diagi * eps2) {					iFault --;					double v = r[ii];					r[ii] = -1.0;					int ij = ii;					int iPlus = i + 1;					for (int j=iPlus ; j<=nVars ; j++) {						ij += (j - 1);						worksp[j] = r[ij];						r[ij] = 0.0;					}					nObs --;					addDataRow(worksp, v);				}			}		}		return iFault;	}}