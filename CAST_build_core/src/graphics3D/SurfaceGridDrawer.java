package graphics3D;import java.awt.*;import models.*;import coreGraphics.*;public class SurfaceGridDrawer {	private int axisSteps;	private double minX, maxX, minZ, maxZ;		public double[][] fitValue;		private ColourMap colourMap;		private int[][] horizGridCoord;	private int[][] vertGridCoord;		public SurfaceGridDrawer(int axisSteps, double minX, double maxX, double minZ, double maxZ) {		this.axisSteps = axisSteps;		this.minX = minX;		this.maxX = maxX;		this.minZ = minZ;		this.maxZ = maxZ;				fitValue = new double[axisSteps + 1][axisSteps + 1];	}		public void setColourMap(ColourMap colourMap) {		this.colourMap = colourMap;	}		public ColourMap getColourMap() {		return colourMap;	}		public void findHeights(SurfaceInterface model) {		double x[] = new double[2];		for (int i=0 ; i<=axisSteps ; i++) {			x[0] = minX + i * (maxX - minX) / axisSteps;			for (int j=0 ; j<=axisSteps ; j++) {				x[1] = minZ + j * (maxZ - minZ) / axisSteps;				fitValue[i][j] = model.getHeight(x);			}		}	}		public void setGridCoords(int[][] horizGridCoord, int[][] vertGridCoord) {		this.horizGridCoord = horizGridCoord;		this.vertGridCoord = vertGridCoord;	}		public double getHeightAt(double xIndex, double zIndex, SurfaceInterface model,																																			double[] xTemp) {		xTemp[0] = minX + xIndex * (maxX - minX) / axisSteps;		xTemp[1] = minZ + zIndex * (maxZ - minZ) / axisSteps;		return model.getHeight(xTemp);	}		public Color getColor(double xIndex, double zIndex, SurfaceInterface model, double[] xTemp) {												//	xIndex & zIndex are 0.5 to (axisSteps - 0.5) for centre of cells												//	xTemp is double[2]		if (colourMap == null)			return Color.lightGray;					double fit = getHeightAt(xIndex, zIndex, model, xTemp);				return colourMap.getColour(fit);	}		private void shadeOneCell(Graphics g, int i, int j, int stepXIndex, int stepZIndex,										SurfaceInterface model, int[] tempPolyHoriz, int[] tempPolyVert,										double contourValue, double[] xTemp) {		Color c = getColor(i + stepXIndex * 0.5, j + stepZIndex * 0.5, model, xTemp);				g.setColor(c);		tempPolyHoriz[4] = tempPolyHoriz[0] = horizGridCoord[i][j];		tempPolyHoriz[1] = horizGridCoord[i + stepXIndex][j];		tempPolyHoriz[2] = horizGridCoord[i + stepXIndex][j + stepZIndex];		tempPolyHoriz[3] = horizGridCoord[i][j + stepZIndex];		tempPolyVert[4] = tempPolyVert[0] = vertGridCoord[i][j];		tempPolyVert[1] = vertGridCoord[i + stepXIndex][j];		tempPolyVert[2] = vertGridCoord[i + stepXIndex][j + stepZIndex];		tempPolyVert[3] = vertGridCoord[i][j + stepZIndex];		g.fillPolygon(tempPolyHoriz, tempPolyVert, 5);//					g.drawPolygon(tempPolyHoriz, tempPolyVert, 5);				g.setColor(Color.black);		drawCellContour(g, i, j, stepXIndex, stepZIndex, model, contourValue, xTemp);	}		private void joinFaces(int face1_low_i, int face1_low_j, int face1_high_i, int face1_high_j,					int face2_low_i, int face2_low_j, int face2_high_i, int face2_high_j, double contourValue,					Graphics g) {		double low1 = fitValue[face1_low_i][face1_low_j];		double propn1 = (contourValue - low1) / (fitValue[face1_high_i][face1_high_j] - low1);//		System.out.println("propn1 = " + propn1);				int horiz1 = (int)Math.round(horizGridCoord[face1_low_i][face1_low_j]														+ propn1 * (horizGridCoord[face1_high_i][face1_high_j]														- horizGridCoord[face1_low_i][face1_low_j]));		int vert1 = (int)Math.round(vertGridCoord[face1_low_i][face1_low_j]														+ propn1 * (vertGridCoord[face1_high_i][face1_high_j]														- vertGridCoord[face1_low_i][face1_low_j]));						double low2 = fitValue[face2_low_i][face2_low_j];		double propn2 = (contourValue - low2) / (fitValue[face2_high_i][face2_high_j] - low2);//		System.out.println("propn2 = " + propn2);				int horiz2 = (int)Math.round(horizGridCoord[face2_low_i][face2_low_j]														+ propn2 * (horizGridCoord[face2_high_i][face2_high_j]														- horizGridCoord[face2_low_i][face2_low_j]));		int vert2 = (int)Math.round(vertGridCoord[face2_low_i][face2_low_j]														+ propn2 * (vertGridCoord[face2_high_i][face2_high_j]														- vertGridCoord[face2_low_i][face2_low_j]));		g.drawLine(horiz1, vert1, horiz2, vert2);	}		private void drawCellContour(Graphics g, int i, int j, int stepXIndex, int stepZIndex,										SurfaceInterface model, double contourValue, double[] xTemp) {		if (Double.isNaN(contourValue))			return;		boolean above00 = contourValue < fitValue[i][j];		boolean above01 = contourValue < fitValue[i][j + stepZIndex];		boolean above10 = contourValue < fitValue[i + stepXIndex][j];		boolean above11 = contourValue < fitValue[i + stepXIndex][j + stepZIndex];				boolean between00_01 = above00 != above01;		boolean between00_10 = above00 != above10;		boolean between01_11 = above01 != above11;		boolean between10_11 = above10 != above11;				if (!between00_01 && !between00_10 && !between01_11 && !between10_11)			return;		//		System.out.println("i = " + i + ", j = " + j + ", stepXIndex = " + stepXIndex + ", stepZIndex = " + stepZIndex);//		System.out.println("between00_01 = " + between00_01 + ", between00_10 = " + between00_10 + ", between01_11 = " + between01_11 + ", between10_11 = " + between10_11);				if (between00_01 && between00_10 && between01_11 && between10_11) {			double fitMiddle = getHeightAt(i + stepXIndex * 0.5, j + stepZIndex * 0.5, model, xTemp);			if (above00 == (fitMiddle < contourValue)) {				joinFaces(i,j, i,j+stepZIndex, i,j, i+stepXIndex,j, contourValue, g);				joinFaces(1,j, i+stepXIndex,j+stepZIndex, i,j+stepZIndex, i+stepXIndex,j+stepZIndex, contourValue, g);			}			else {				joinFaces(i,j, i,j+stepZIndex, i,j, i+stepXIndex,j, contourValue, g);				joinFaces(1,j, i+stepXIndex,j+stepZIndex, i,j+stepZIndex, i+stepXIndex,j+stepZIndex, contourValue, g);			}		}		else if (between00_10 && between00_01)				joinFaces(i,j, i+stepXIndex,j, i,j, i,j+stepZIndex, contourValue, g);		else if (between00_10 && between01_11)				joinFaces(i,j, i+stepXIndex,j, i,j+stepZIndex, i+stepXIndex,j+stepZIndex, contourValue, g);		else if (between00_10 && between10_11)				joinFaces(i,j, i+stepXIndex,j, i+stepXIndex,j, i+stepXIndex,j+stepZIndex, contourValue, g);		else if (between00_01 && between01_11)				joinFaces(i,j, i,j+stepZIndex, i,j+stepZIndex, i+stepXIndex,j+stepZIndex, contourValue, g);		else if (between00_01 && between10_11)				joinFaces(i,j, i,j+stepZIndex, i+stepXIndex,j, i+stepXIndex,j+stepZIndex, contourValue, g);		else if (between01_11 && between10_11)				joinFaces(i,j+stepZIndex, i+stepXIndex,j+stepZIndex, i+stepXIndex,j, i+stepXIndex,j+stepZIndex, contourValue, g);	}		public void shadeSurface(Graphics g, SurfaceInterface model, double contourValue,												int startXIndex, int stepXIndex, int minXLoopIndex, int maxXLoopIndex,												int startZIndex, int stepZIndex, int minZLoopIndex, int maxZLoopIndex,												boolean startDrawingX) {		int tempPolyHoriz[] = new int[5];		int tempPolyVert[] = new int[5];		double xTemp[] = new double[2];		if (startDrawingX)			for (int i=startXIndex ; i>=minXLoopIndex && i<=maxXLoopIndex ; i+=stepXIndex)				for (int j=startZIndex ; j>=minZLoopIndex && j<=maxZLoopIndex ; j+=stepZIndex)					shadeOneCell(g, i, j, stepXIndex, stepZIndex, model, tempPolyHoriz,																																tempPolyVert, contourValue, xTemp);		else			for (int j=startZIndex ; j>=minZLoopIndex && j<=maxZLoopIndex ; j+=stepZIndex)				for (int i=startXIndex ; i>=minXLoopIndex && i<=maxXLoopIndex ; i+=stepXIndex)					shadeOneCell(g, i, j, stepXIndex, stepZIndex, model, tempPolyHoriz,																																tempPolyVert, contourValue, xTemp);	}		public void frameSurface(Graphics g) {//		for (int i=0 ; i<=axisSteps ; i++)		//	only draw every second line in grid		for (int i=0 ; i<=axisSteps ; i+=2)			for (int j=0 ; j<axisSteps ; j++)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i][j + 1], vertGridCoord[i][j + 1]);				for (int i=0 ; i<axisSteps ; i++)//			for (int j=0 ; j<=axisSteps ; j++)		//	only draw every second line in grid			for (int j=0 ; j<=axisSteps ; j+=2)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i + 1][j], vertGridCoord[i + 1][j]);			}		public void drawContour(Graphics g, SurfaceInterface model, double contourValue) {		double xTemp[] = new double[2];		for (int i=0 ; i<axisSteps ; i++)			for (int j=0 ; j<axisSteps ; j++)				drawCellContour(g, i, j, 1, 1, model, contourValue, xTemp);	}		public void outlineSurface(Graphics g) {		for (int i=0 ; i<=axisSteps ; i+=axisSteps)			for (int j=0 ; j<axisSteps ; j++)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i][j + 1], vertGridCoord[i][j + 1]);				for (int i=0 ; i<axisSteps ; i++)			for (int j=0 ; j<=axisSteps ; j+=axisSteps)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i + 1][j], vertGridCoord[i + 1][j]);			}	}