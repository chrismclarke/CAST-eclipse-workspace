package graphics3D;public class RotateThread extends Thread {	static final private int kAutoDegreesPerSecond = 60;	static final protected int kStepsPerSecond = 30;	static final private int kDegreeSteps = 1;		protected Rotate3DView theView;	private boolean rotate360 = true;//	private int rotateIndex;	protected double round1, of1, round2, of2;		public RotateThread(Rotate3DView theView) {		super();		this.theView = theView;	}		public RotateThread(Rotate3DView theView, double round1, double of1, double round2,																									double of2) {		this(theView);		this.round1 = round1;		this.of1 = of1;		this.round2 = round2;		this.of2 = of2;		rotate360 = false;	}		public RotateThread(Rotate3DView theView, double round2, double of2) {										//	 round1 and of1 must be set with setInitialRotation()		this(theView);		this.round2 = round2;		this.of2 = of2;		rotate360 = false;	}		public void setInitialRotation(double round1, double of1) {		this.round1 = round1;		this.of1 = of1;	}		protected void coreRotate() throws InterruptedException {		double roundDiff = round2 - round1;		if (roundDiff > 180)			roundDiff = roundDiff - 360;		else if (roundDiff < -180)			roundDiff = roundDiff + 360;		double ofDiff = of2 - of1;		if (ofDiff > 180)			ofDiff = ofDiff - 360;		else if (ofDiff < -180)			ofDiff = ofDiff + 360;						double maxDiff = Math.max(Math.abs(roundDiff), Math.abs(ofDiff));		int nSteps = (int) Math.rint(maxDiff / kDegreeSteps);		for (int step=1 ; step<=nSteps ; step++) {			theView.rotateTo(round1 + (roundDiff * step) / nSteps,																of1 + (ofDiff * step) / nSteps);			Thread.sleep(1000 / kStepsPerSecond);		}	}		public void run() {		try {			if (rotate360)				for (int rotateIndex=0 ; rotateIndex<360 ; rotateIndex++) {					theView.rotateOneDegree();					Thread.sleep(1000 / kAutoDegreesPerSecond);				}			else				coreRotate();		} catch (InterruptedException e) {		}		theView.repaint();		theView.clearRotateThread();	}}