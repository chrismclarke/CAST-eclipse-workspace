package graphics3D;import java.awt.*;import dataView.*;import distn.*;import models.*;public class Normal3DArtist {	private DistnInfo distnInfo;		private Rotate3DView theView;	private String distnKey, xKey;	private DataSet data;	private RotateMap map;	private D3Axis yAxis, xAxis;		private int outlineH[];	private int outlineV[];	private int pointsUsed;		private Color shadeColor = Color.lightGray;	private Color highlightColor = Color.blue;		private boolean drawOutline;	private double inverseScalingFactor = 1.2;	//	max density is inverse of this		private double fixedMinSD = -1.0;		public Normal3DArtist(Rotate3DView theView, String distnKey, String xKey, DataSet data,														D3Axis yAxis, D3Axis xAxis, boolean drawOutline) {		this.distnKey = distnKey;		this.xKey = xKey;		this.data = data;		this.yAxis = yAxis;		this.xAxis = xAxis;		this.theView = theView;		this.drawOutline = drawOutline;		distnInfo = new NormalInfo();	}		public void setOutlineDraw(boolean drawOutline) {		this.drawOutline = drawOutline;	}		public void setFixedMinSD(double fixedMinSD) {		this.fixedMinSD = fixedMinSD;	}		public void setInverseScalingFactor(double inverseScalingFactor) {		this.inverseScalingFactor = inverseScalingFactor;	}		private void addPointToPoly(double d, double y, double x, Point tempPoint) {		tempPoint = theView.translateToScreen(map.mapH3DGraph(d, y, x),											map.mapV3DGraph(d, y, x), tempPoint);		outlineH[pointsUsed] = tempPoint.x;		outlineV[pointsUsed ++] = tempPoint.y;	}		private void paint3DPoly(Graphics g, double lowY, double highY, Color fillColour, Value x,																			double densityFactor, double xPropn) {		if (lowY >= highY)			return;				CoreModelVariable distn = (CoreModelVariable)data.getVariable(distnKey);				DistnPoints p0 = distnInfo.getLowPoints();		DistnPoints p1 = distnInfo.getHighPoints();				if (outlineH == null || outlineH.length != (p0.elementsUsed + p1.elementsUsed + 3)) {			outlineH = new int[p0.elementsUsed + p1.elementsUsed + 3];			outlineV = new int[p0.elementsUsed + p1.elementsUsed + 3];		}				pointsUsed = 0;		Point tempPoint = new Point(0, 0);				double yPropn = yAxis.numValToPosition(lowY);		addPointToPoly(0.0, yPropn, xPropn, tempPoint);		double lowZ = distn.yToZ(lowY, x);		double lowDensity = distnInfo.lookup(lowZ) * densityFactor;		addPointToPoly(lowDensity, yPropn, xPropn, tempPoint);				for (int i=p0.elementsUsed-1 ; i>=0 ; i--) {			double nextY = distn.zToY(p0.z[i], x);			if (nextY > lowY && nextY < highY) {				yPropn = yAxis.numValToPosition(nextY);				double density = distnInfo.lookup(distn.yToZ(nextY, x)) * densityFactor;				addPointToPoly(density, yPropn, xPropn, tempPoint);			}		}		for (int i=1 ; i<p1.elementsUsed ; i++) {			double nextY = distn.zToY(p1.z[i], x);			if (nextY > lowY && nextY < highY) {				yPropn = yAxis.numValToPosition(nextY);				double density = distnInfo.lookup(distn.yToZ(nextY, x)) * densityFactor;				addPointToPoly(density, yPropn, xPropn, tempPoint);			}		}				yPropn = yAxis.numValToPosition(highY);		double highDensity = distnInfo.lookup(distn.yToZ(highY, x)) * densityFactor;		addPointToPoly(highDensity, yPropn, xPropn, tempPoint);		addPointToPoly(0.0, yPropn, xPropn, tempPoint);				if (fillColour != null) {			Color oldColor = g.getColor();			g.setColor(fillColour);			g.fillPolygon(outlineH, outlineV, pointsUsed);			g.setColor(oldColor);		}				if (drawOutline)			for (int i=1 ; i<pointsUsed-2 ; i++)				g.drawLine(outlineH[i], outlineV[i], outlineH[i+1], outlineV[i+1]);	}		public void paintDistn(Graphics g, Value x) {		paintDistn(g, x, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);	}		synchronized public void paintDistn(Graphics g, Value x,															double lowHighlightY, double highHighlightY) {		if (distnKey == null)			return;				map = theView.getCurrentMap();				CoreModelVariable distn = (CoreModelVariable)data.getVariable(distnKey);		double lowestY = distn.evaluateMean(x) - distnInfo.zMax() * distn.evaluateSD(x).toDouble();		lowHighlightY = Math.max(lowestY, lowHighlightY);				double highestY = distn.evaluateMean(x) + distnInfo.zMax() * distn.evaluateSD(x).toDouble();		highHighlightY = Math.min(highestY, highHighlightY);				double tempMinSD = fixedMinSD;		if (fixedMinSD <= 0.0)			tempMinSD = distn.getMinSD().toDouble();		double densityFactor = tempMinSD / distn.evaluateSD(x).toDouble() / inverseScalingFactor																						/ distnInfo.maxDensity();		double xPropn;		if (x instanceof NumValue)			xPropn = xAxis.numValToPosition(((NumValue)x).toDouble());		else {			CatVariable xVar = (CatVariable)data.getVariable(xKey);			xPropn = xAxis.catValToPosition(xVar.labelIndex(x), xVar.noOfCategories());		}				paint3DPoly(g, lowestY, lowHighlightY, highlightColor, x, densityFactor, xPropn);		paint3DPoly(g, lowHighlightY, highHighlightY, shadeColor, x, densityFactor, xPropn);		paint3DPoly(g, highHighlightY, highestY, highlightColor, x, densityFactor, xPropn);	}		public void setFillColor(Color c) {		shadeColor = c;	}		public void setHighlightColor(Color c) {		highlightColor = c;	}}