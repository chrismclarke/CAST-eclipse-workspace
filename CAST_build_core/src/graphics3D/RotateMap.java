package graphics3D;import java.awt.*;import axis.*;public class RotateMap {	static final private double degToRad = 2.0 * Math.PI / 360;//	static final private double kRootTwo = 1.414214;//	static final private double kRootOneHalf = 1.224745;	static final private double kInvRootTwo = 0.707107;	static final private double kInvRootThree = 0.577350;//	static final private double kRootTwoThirds = 0.816497;		private double theta1, theta2;	private double sin1, cos1, sin2, cos2, transDV, transYV, transXV, transYH, transXH;	private double sinsinRatio, cossinRatio;		private int hCentre, vCentre, axisPix;		public RotateMap(double roundDens, double ofDens) {		setAngles(roundDens, ofDens);	}		public RotateMap(RotateMap originalMap) {		this(originalMap.getTheta1(), originalMap.getTheta2());		hCentre = originalMap.hCentre;		vCentre = originalMap.vCentre;		axisPix = originalMap.axisPix;	}		public boolean yAxisBehind() {		return theta1 < 90 || theta1 >= 270;	}		public boolean xAxisBehind() {		return theta1 < 90 || theta1 >= 270;	}		public boolean zAxisBehind() {		return theta1 >= 180;	}		public double getTheta1() {		return theta1;	}		public double getTheta2() {		return theta2;	}		public double getSinTheta1() {		return sin1;	}		public double getCosTheta1() {		return cos1;	}		public void setAngles(double roundDens, double ofDens) {					//		0 <= ofDens <= 90   --> density axis points towards us					//		270 <= ofDens < 360 --> dendity axis points away					//		roundDens = 0   --> z axis points directly towards us (& x-axis points right)					//		roundDens = 90  --> x axis points directly away from us		theta1 = roundDens % 360;		theta2 = ofDens;//		System.out.println("angles: (" + theta1 + ", " + theta2 + ")");		if (roundDens == 90) {		//		to avoid rounding errors when rotate button clicked			sin1 = 1.0;			cos1 = 0.0;		}		else {			sin1 = Math.sin(degToRad * roundDens);			cos1 = Math.cos(degToRad * roundDens);		}		if (ofDens == 90) {		//		to avoid rounding errors when rotate button clicked			sin2 = 1.0;			cos2 = 0.0;		}		else {			sin2 = Math.sin(degToRad * ofDens);			cos2 = Math.cos(degToRad * ofDens);		}		transDV = cos2;		transYV = sin1 * sin2;		transXV = -(cos1 * sin2);		transYH = cos1;		transXH = sin1;		if (theta2 == 0 || theta2 == 180) {			sinsinRatio = 0.0;			cossinRatio = 0.0;		}		else {			sinsinRatio = sin1 / sin2;			cossinRatio = cos1 / sin2;		}	}		public void setDimensions(Dimension dim, int axisWidth, int axisHt) {		hCentre = (dim.width + axisWidth) / 2;		vCentre = (dim.height + axisHt) / 2;		axisPix = (int)Math.min((dim.width - axisWidth) * kInvRootTwo,																			(dim.height - axisHt) * kInvRootThree);	}			public int mapH3DGraph(double d, double y, double x) {		double rotatedH = (y - 0.5) * transYH + (x - 0.5) * transXH;		return hCentre + (int)Math.round(rotatedH * axisPix);	}		public int mapV3DGraph(double d, double y, double x) {		double rotatedV = (d - 0.5) * transDV + (y - 0.5) * transYV + (x - 0.5) * transXV;		return vCentre + (int)Math.round(rotatedV * axisPix);	}		public double mapToD(Point thePoint) throws AxisException {						//		maps thePoint.v to D axis at centre of x-y plane		double v = (double)(thePoint.y - vCentre) / axisPix;		if (theta2 == 90 || theta2 == 270)			if (v > 0)				throw new AxisException(AxisException.TOO_HIGH_ERROR);			else				throw new AxisException(AxisException.TOO_LOW_ERROR);		else			return v / cos2 + 0.5;	}		public double mapToD(Point thePoint, double y, double x) throws AxisException {						//		maps thePoint.v to D axis at (x, y)		int v2Centre = mapV3DGraph(0.5, y, x);		double v = (double)(thePoint.y - v2Centre) / axisPix;		if (theta2 == 90 || theta2 == 270)			if (v > 0)				throw new AxisException(AxisException.TOO_HIGH_ERROR);			else				throw new AxisException(AxisException.TOO_LOW_ERROR);		else			return v / cos2 + 0.5;	}		public double mapToY(Point thePoint) {		double v = (double)(thePoint.y - vCentre) / axisPix;		double h = (double)(thePoint.x - hCentre) / axisPix;		double tempReal = v + cos2;		return cos1 * h + sinsinRatio * tempReal + 0.5;	}	public double mapToX(Point thePoint) {		double v = (double)(thePoint.y - vCentre) / axisPix;		double h = (double)(thePoint.x - hCentre) / axisPix;		double tempReal = v + cos2;		return sin1 * h - cossinRatio * tempReal + 0.5;	}	public double[] mapToYX(Point thePoint) {		double v = (double)(thePoint.y - vCentre) / axisPix;		double h = (double)(thePoint.x - hCentre) / axisPix;		double tempReal = v + 0.5 * cos2;				double result[] = new double[2];		result[0] = cos1 * h + sinsinRatio * tempReal + 0.5;	//	y		result[1] = sin1 * h - cossinRatio * tempReal + 0.5;	//	x		return result;	}		private double startTheta1, startTheta2;		public void startDrag() {		startTheta1 = theta1;		startTheta2 = theta2;	}	public void dragRotate(int hDrag, int vDrag) {		final double piDenom = 57.2957795;    			//   180 / pi   //		double t2Change = (vDrag * piDenom) / axisPix;		double t1Change = (hDrag * piDenom) / axisPix;																	//  should be divided by  cosDegree [ startAngle2 ]		double changedTheta2 = (startTheta2 + t2Change) % 360;		if (changedTheta2 < 0)			changedTheta2 += 360;		if (changedTheta2 >= 90 && changedTheta2 < 180)			changedTheta2 = 90;		else if (changedTheta2 >= 180 && changedTheta2 < 270)			changedTheta2 = 270;		double changedTheta1 = (startTheta1 + t1Change) % 360;		if (changedTheta1 < 0)			changedTheta1 += 360;				setAngles(changedTheta1, changedTheta2);	}}