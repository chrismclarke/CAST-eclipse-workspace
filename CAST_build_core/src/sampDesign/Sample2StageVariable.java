package sampDesign;import java.util.*;import dataView.*;public class Sample2StageVariable extends NumFunctionVariable implements SampleInterface {	static final public int TWO_STAGE = 0;	static final public int SIMPLE = 1;		static final private NumValue kNaNValue = new NumValue(Double.NaN, 0);		private int nPrimary, nSecondary;	private String clusterKey;	private ClusterSampleVariable clusterVariable;		private Random sampleGenerator;	private long currentSeed, nextSeed;		private boolean unitInSample[];	private boolean clusterInSample[];		private int samplingScheme = TWO_STAGE;		public Sample2StageVariable(String theName, DataSet data, String clusterKey,																				long randomSeed, int nPrimary, int nSecondary) {		super(theName);				this.clusterKey = clusterKey;		clusterVariable = (ClusterSampleVariable)data.getVariable(clusterKey);		unitInSample = new boolean[clusterVariable.noOfValues()];		clusterInSample = new boolean[clusterVariable.getNoOfClusters()];				sampleGenerator = new Random(randomSeed);		nextSeed = sampleGenerator.nextLong();		setSampleSizes(nPrimary, nSecondary);	}		public void setSamplingScheme(int scheme) {		samplingScheme = scheme;	}		public int getNPrimaryUnits() {		return clusterVariable.getNoOfClusters();	}		public int getNSecondaryUnits() {		return clusterVariable.getClusterSize();	}		public int getMaxDecimals() {		return clusterVariable.getMaxDecimals();	}		public int noOfValues() {		return clusterVariable.noOfValues();	}		public Value valueAt(int index) {		return unitInSample[index] ? clusterVariable.valueAt(index) : kNaNValue;	}		public Value popnValueAt(int index) {		return clusterVariable.valueAt(index);	}		public int getSampleSize() {		return nPrimary * nSecondary;	}		public int getPrimarySampleSize() {		return nPrimary;	}		public boolean primaryUnitSampled(int index) {		return clusterInSample[index];	}		public boolean secondaryUnitSampled(int index) {		return unitInSample[index];	}			public void setSampleSize(int n) {							//		not meaningful for 2-stage sample	}		public void setSampleSizes(int nPrimary, int nSecondary) {		this.nPrimary = nPrimary;		this.nSecondary = nSecondary;	}		public void clearSample() {		for (int i=0 ; i<unitInSample.length ; i++)			unitInSample[i] = false;		for (int i=0 ; i<clusterInSample.length ; i++)			clusterInSample[i] = false;	}		public long generateNextSample() {		currentSeed = nextSeed;		sampleGenerator.setSeed(nextSeed);				doSelectSample();				nextSeed = sampleGenerator.nextLong();		return currentSeed;	}		public boolean setSampleFromSeed(long newSeed) {		if (currentSeed == newSeed)			return false;		currentSeed = newSeed;		sampleGenerator.setSeed(newSeed);				doSelectSample();				return true;	}		public void setNextSeed(long nextSeed) {		//	only used when setting up exercise with fixed seed		this.nextSeed = nextSeed;	}		private void doSelectSample() {		int popPrimary = getNPrimaryUnits();		int popSecondary = getNSecondaryUnits();		if (samplingScheme == TWO_STAGE) {			int sampleLeft = nPrimary;			int popnLeft = popPrimary;			int index = 0;			for (int cluster=0 ; cluster<popPrimary ; cluster++) {				boolean inPrimary = (sampleLeft > 0 && sampleLeft >=																										popnLeft * sampleGenerator.nextDouble());				clusterInSample[cluster] = inPrimary;				if (inPrimary) {					int sample2Left = nSecondary;					int popn2Left = popSecondary;					for (int i=0 ; i<popSecondary ; i++) {						boolean inSecondary = (sample2Left > 0 && sample2Left >=																									popn2Left * sampleGenerator.nextDouble());						unitInSample[index ++] = inSecondary;						if (inSecondary)							sample2Left --;						popn2Left --;					}					sampleLeft --;				}				else					for (int i=0 ; i<popSecondary ; i++)						unitInSample[index ++] = false;				popnLeft --;			}		}		else {			for (int cluster=0 ; cluster<popPrimary ; cluster++)				clusterInSample[cluster] = false;			int sampleLeft = nPrimary * nSecondary;			int popnLeft = popPrimary * popSecondary;			for (int i=0 ; i<popPrimary * popSecondary ; i++) {				boolean inSample = (sampleLeft > 0 && sampleLeft >=																							popnLeft * sampleGenerator.nextDouble());				unitInSample[i] = inSample;				if (inSample)					sampleLeft --;				popnLeft --;			}		}	}			public boolean noteVariableChange(String key) {		return clusterKey.equals(key);	}//-----------------------------------------------------------	private double syy, sy, sMeanMean;		public void calcTwoStageInfo() {		int N = getNPrimaryUnits();		int Ns = getNSecondaryUnits();				ValueEnumeration ye = clusterVariable.values();		sy = 0.0;		syy = 0.0;		sMeanMean = 0.0;		for (int i=0 ; i<N ; i++) {			double sumi = 0.0;			for (int j=0 ; j<Ns ; j++) {				double y = ye.nextDouble();				sumi += y;				syy += y * y;			}			sy += sumi;			double meani = sumi / Ns;			sMeanMean += meani * meani;		}	}		public double getMean() {		int N = getNPrimaryUnits();		int Ns = getNSecondaryUnits();		double mean = sy / (N * Ns);		return mean;	}		public double getSD() {		if (samplingScheme == TWO_STAGE) {			double N = getNPrimaryUnits();			double n = nPrimary;			double Ns = getNSecondaryUnits();			double ns = nSecondary;						double term1 = n * (Ns - ns) / ns / N / Ns / (Ns - 1) * (syy - Ns * sMeanMean);						double term2 = n * (N - n) / N / (N - 1) * (sMeanMean - sy * sy / N / Ns / Ns);						double sd = Math.sqrt(term1 + term2) / n;			return sd;		}		else {			int N = getNPrimaryUnits() * getNSecondaryUnits();			int n = nPrimary * nSecondary;			double v = ((syy - sy * sy / N) * (N - n)) / (N * n * (N - 1));			return Math.sqrt(v);		}	}}