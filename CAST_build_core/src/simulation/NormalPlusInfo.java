package simulation;import distn.*;public class NormalPlusInfo extends DistnInfo {	static final private double invRoot2Pi = 1.0 / Math.sqrt(2.0 * Math.PI);		private double a, b;	private double bMin, bMax, bNormal, zPolyMax;		public NormalPlusInfo (double a, double b, double bMin, double bMax, double bNormal,																									double zPolyMax) {		super();		this.a = a;		this.b = b;		this.bMin = bMin;		this.bMax = bMax;		this.bNormal = bNormal;		this.zPolyMax = zPolyMax;	}		public double zMin() {		return -4.0;	}		public double zMax() {		return (b >= bMax) ? (a + 0.00001) : Math.max(4.0, zPolyMax);	}		public double zMode() {		return 0.0;				//	Not really the mode but we want to keep density at 0 constant	}		public boolean isSymmetric() {		return false;	}		public double getDensity(double z) {		double normalDensity = invRoot2Pi * Math.exp(-0.5 * z * z);		if (z <= 0)			return normalDensity;		else {			double polyDensity = 0.0;			if (z <= a)				polyDensity = invRoot2Pi - z * (invRoot2Pi - b) / a;			else if (z <= zPolyMax)				polyDensity = b - (z - a) * b / (zPolyMax - a);						double p = polyPropn();			return normalDensity * (1.0 - p) + polyDensity * p;		}	}		private double polyPropn() {//		return 1.0;		return (b < bNormal) ? (bNormal - b) / (bNormal - bMin)									: (b - bNormal) / (bMax - bNormal);	}		public boolean sameParams(ContinDistnVariable v) {		if (!(v instanceof NormalPlusDistnVariable))			return false;		else {			NormalPlusDistnVariable other = (NormalPlusDistnVariable)v;			return a == other.getA() && b == other.getB();		}	}}