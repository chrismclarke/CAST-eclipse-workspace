package simulation;import java.awt.*;import java.util.*;import dataView.*;import coreSummaries.*;import simulationProg.*;public class PropnCIsListView extends PropnCIsView {//	static final public String PROPN_CIS_VIEW = "propnCIsView";		static final private int kHeadingHorizSpacing = 10;	static final private int kHeadingLineGap = 2;	static final private int kHeadingVertSpacing = 8;	static final private int kLeftBorder = 0;	static final private int kRightBorder = 20;	static final private int kMinRowGap = 8;		private LabelValue probLabel1, probLabel2, propnLabel, ciLabel1, ciLabel2;		static final private String kDivideString = " / ";		protected int ciDecimals;		private Font boldFont;		private boolean initialised = false;	private int ascent, boldAscent, boldDescent;	private int headingHeight, probHeadingWidth, propnHeadingWidth, ciHeadingWidth,														halfDivideWidth;	private NumValue topCount = new NumValue(0.0, 0);	private NumValue totalCount = new NumValue(0.0, 0);		private int minWidth, minHeight;		public PropnCIsListView(DataSet theData, PropnCIXApplet applet, String pKey, String resultKey,									NumValue[] pMatchWin, int selectedIndex, int ciDecimals) {		super(theData, applet, pKey, resultKey, pMatchWin, selectedIndex);				this.ciDecimals = ciDecimals;		boldFont = applet.getStandardBoldFont();				StringTokenizer st = new StringTokenizer(applet.translate("P(Team A*wins match)"), "*");		probLabel1 = new LabelValue(st.nextToken());		probLabel2 = new LabelValue(st.nextToken());		propnLabel = new LabelValue(applet.translate("Team A top"));		st = new StringTokenizer(applet.translate("95% CI for*P(Team A top)"), "*");		ciLabel1 = new LabelValue(st.nextToken());		ciLabel2 = new LabelValue(st.nextToken());	}		protected boolean initialise(Graphics g) {		if (!initialised) {			FontMetrics fm = g.getFontMetrics();			ascent = fm.getAscent();						halfDivideWidth = fm.stringWidth(kDivideString) / 2 + 1;						g.setFont(boldFont);			fm = g.getFontMetrics();			boldAscent = fm.getAscent();			boldDescent = fm.getDescent();						headingHeight = 2 * (boldAscent + boldDescent) + kHeadingLineGap																						+ kHeadingVertSpacing;						probHeadingWidth = Math.max(probLabel1.stringWidth(g), probLabel2.stringWidth(g));			propnHeadingWidth = propnLabel.stringWidth(g);			ciHeadingWidth = Math.max(ciLabel1.stringWidth(g), ciLabel2.stringWidth(g));						minHeight = (ascent + kMinRowGap) * pMatchWin.length + headingHeight + 2;			minWidth = probHeadingWidth + propnHeadingWidth + ciHeadingWidth										+ 2 * kHeadingHorizSpacing + kLeftBorder + kRightBorder + 2;						initialised = true;			return true;		}		else			return false;	}		public Dimension getMinimumSize() {		initialise(getGraphics());		return new Dimension(minWidth, minHeight);	}		public Dimension getPreferredSize() {		return getMinimumSize();	}		private int getRowHeight() {		return (getSize().height - headingHeight - 2) / pMatchWin.length;	}		public void paintView(Graphics g) {		initialise(g);		findCIs();				int horizOffset = (getSize().width - minWidth) / 2;				int probCenter = horizOffset + kLeftBorder + 1 + probHeadingWidth / 2;		int propnCenter = horizOffset + kLeftBorder + 1 + probHeadingWidth														+ kHeadingHorizSpacing + propnHeadingWidth / 2;		int ciCenter = horizOffset + kLeftBorder + 1 + probHeadingWidth								+ propnHeadingWidth + 2 * kHeadingHorizSpacing + ciHeadingWidth / 2;				Font stdFont = g.getFont();		g.setFont(boldFont);				probLabel1.drawCentred(g, probCenter, boldAscent);		probLabel2.drawCentred(g, probCenter, 2 * boldAscent + boldDescent + kHeadingLineGap);				propnLabel.drawCentred(g, propnCenter, boldAscent												+ (boldAscent + boldDescent + kHeadingLineGap) / 2);				ciLabel1.drawCentred(g, ciCenter, boldAscent);		ciLabel2.drawCentred(g, ciCenter, 2 * boldAscent + boldDescent + kHeadingLineGap);				g.setFont(stdFont);				int rowHeight = getRowHeight();				g.setColor(Color.white);		g.fillRect(horizOffset, headingHeight, minWidth, rowHeight * pMatchWin.length);		g.setColor(getForeground());				IntervalValue ci = new IntervalValue(0.0, 0.0, ciDecimals);				int baseline = headingHeight + 1 + (rowHeight + ascent) / 2;		for (int i=0 ; i<pMatchWin.length ; i++) {			if (i == selectedIndex) {				g.setColor(Color.yellow);				g.fillRect(horizOffset + 1, headingHeight + 1 + i * rowHeight, minWidth - 2,																										rowHeight);				g.setColor(getForeground());				g.drawRect(horizOffset, headingHeight + 1 + i * rowHeight, minWidth - 1,																									rowHeight - 1);				g.setColor(kDarkRed);				g.setFont(boldFont);			}						pMatchWin[i].drawCentred(g, probCenter, baseline);						topCount.setValue(x[i]);			totalCount.setValue(n[i]);						topCount.drawLeft(g, propnCenter - halfDivideWidth, baseline);			g.drawString(kDivideString, propnCenter - halfDivideWidth, baseline);			totalCount.drawRight(g, propnCenter + halfDivideWidth, baseline);						ci.lowValue.setValue(ciLow[i]);			ci.highValue.setValue(ciHigh[i]);			ci.drawCentred(g, ciCenter, baseline);						if (i == selectedIndex) {				g.setColor(getForeground());				g.setFont(stdFont);			}						baseline += rowHeight;		}		g.drawRect(horizOffset, headingHeight, minWidth - 1, rowHeight * pMatchWin.length - 1);	}		protected int getHitIndex(int x, int y) {		int rowHeight = getRowHeight();		if (y < headingHeight || y >= getSize().height)			return -1;		else			return Math.min(pMatchWin.length - 1, (y - headingHeight) / rowHeight);	}}	