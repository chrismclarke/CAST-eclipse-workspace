package simulation;import distn.*;public class NormalPlusDistnVariable extends NormalDistnVariable {	static final private double invRoot2Pi = 1.0 / Math.sqrt(2.0 * Math.PI);	static final private double overallZMax = 5.0;//	static final private int kMaxIterations = 5;	static final private double kZAccuracy = 0.00001;		private double a, b;		private double bMin, bMax, bNormal;	private double zPolyMax;		public NormalPlusDistnVariable(String theName) {		super(theName);		setA(1.0);		setB(bNormal);	}		public void setA(double a) {		this.a = a;		bMin = (1.0 - a * invRoot2Pi) / overallZMax;		bNormal = invRoot2Pi * (1.0 - a * invRoot2Pi);		bMax = 1.0 / a - invRoot2Pi;	}		public double getA() {		return a;	}		public void setB(double b) {		this.b = Math.max(bMin, Math.min(bMax, b));		zPolyMax = Math.max(a, (1.0 - a * invRoot2Pi) / b);	}		public double getB() {		return b;	}		public double getBMax() {		return bMax;	}		public double getBMin() {		return bMin;	}		public double getBNormal() {		return bNormal;	}		public double getZMax() {		return (b >= bMax) ? (a + 0.00001) : Math.max(4.0, zPolyMax);	}		public double getZMode() {		return 0.0;//		return (b <= invRoot2Pi) ? 0.0 : a;	}		public double getDensityFactor() {		return getSD().toDouble();	}		public double getMaxScaledDensity() {		return Math.max(b, invRoot2Pi);	}		public double getScaledDensity(double x) {		return getStdDensity((x - getMean().toDouble()) / getSD().toDouble());	}		private double getStdDensity(double z) {		double normalDensity = invRoot2Pi * Math.exp(-0.5 * z * z);		if (z <= 0)			return normalDensity;		else {			double polyDensity = 0.0;			if (z <= a)				polyDensity = invRoot2Pi - z * (invRoot2Pi - b) / a;			else if (z <= zPolyMax) {				double denom = zPolyMax - a;				polyDensity = (denom <= 0) ? b : b - (z - a) * b / denom;			}						double p = polyPropn();			return normalDensity * (1.0 - p) + polyDensity * p;		}	}		private double polyPropn() {//		return 1.0;		return (b < bNormal) ? (bNormal - b) / (bNormal - bMin)									: (b - bNormal) / (bMax - bNormal);	}		public double getCumulativeProb(double v) {		return getStdCumulativeProb((v - getMean().toDouble()) / getSD().toDouble());	}		public double getStdCumulativeProb(double z) {		double normalP = stdCumProb(z);		if (z <= 0.0)			return normalP;		else {			double polyP = 0.0;			if (z <= a)				polyP = 0.5 + z * (invRoot2Pi - z * 0.5 * (invRoot2Pi - b) / a);			else if (z <= zPolyMax)				polyP = 0.5 + a * 0.5 * (invRoot2Pi + b) + (z - a) * b * (1.0 - 0.5 * (z - a) / (zPolyMax - a));			else				polyP = 1.0;			double p = polyPropn();			return normalP * (1.0 - p) + polyP * p;		}	}		public double getQuantile(double prob) {		double z = stdQuantile(prob);		if (prob > 0.5) {			double z0 = 0.0;			double error0 = getStdCumulativeProb(z0) - prob;			double z1 = getZMax();//			double error1 = getStdCumulativeProb(z1) - prob;			while (Math.abs(z1 - z0) > kZAccuracy) {//				double zTest = z0 - error0 * (z1 - z0) / (error1 - error0);				double zTest = 0.5 * (z0 + z1);				double errorTest = getStdCumulativeProb(zTest) - prob;				if ((errorTest >= 0.0) == (error0 >= 0.0)) {					z0 = zTest;					error0 = errorTest;				}				else {					z1 = zTest;//					error1 = errorTest;				}			}			z = 0.5 * (z0 + z1);		}		return getMean().toDouble() + z * getSD().toDouble();	}		public DistnInfo getDistnInfo() {		return new NormalPlusInfo(a, b, bMin, bMax, bNormal, zPolyMax);	}}