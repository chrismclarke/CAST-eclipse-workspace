package simulation;import java.awt.*;import dataView.*;import axis.*;import simulationProg.*;public class PropnCIsDrawView extends PropnCIsView {//	static final public String PROPN_CI_DRAW_VIEW = "propnCIDrawView";		private HorizAxis horizAxis;	private VertAxis vertAxis;		public PropnCIsDrawView(DataSet theData, PropnCIXApplet applet, String pKey, String resultKey,									NumValue[] pMatchWin, int selectedIndex, HorizAxis horizAxis,									VertAxis vertAxis) {		super(theData, applet, pKey, resultKey, pMatchWin, selectedIndex);				this.horizAxis = horizAxis;		this.vertAxis = vertAxis;	}		public void paintView(Graphics g) {		findCIs();				Point lowPoint = null;		Point highPoint = null;		for (int i=0 ; i<pMatchWin.length ; i++)			try {				int horizPos = horizAxis.numValToPosition(pMatchWin[i].toDouble());				int vertPos = vertAxis.numValToPosition(ciLow[i]);				lowPoint = translateToScreen(horizPos, vertPos, lowPoint);				vertPos = vertAxis.numValToPosition(ciHigh[i]);				highPoint = translateToScreen(horizPos, vertPos, highPoint);								if (i == selectedIndex) {					g.setColor(Color.yellow);										double leftX, rightX;					if (i == 0) {						rightX = (pMatchWin[0].toDouble() + pMatchWin[1].toDouble()) * 0.5;						leftX = (3.0 * pMatchWin[0].toDouble() - pMatchWin[1].toDouble()) * 0.5;					}					else if (i == pMatchWin.length - 1) {						leftX = (pMatchWin[pMatchWin.length - 1].toDouble()															+ pMatchWin[pMatchWin.length - 2].toDouble()) * 0.5;						rightX = (3.0 * pMatchWin[pMatchWin.length - 1].toDouble()															- pMatchWin[pMatchWin.length - 2].toDouble()) * 0.5;					}					else {						rightX = (pMatchWin[i].toDouble() + pMatchWin[i + 1].toDouble()) * 0.5;						leftX = (pMatchWin[i].toDouble() + pMatchWin[i - 1].toDouble()) * 0.5;					}										int horizLeftHilitePos = horizAxis.numValToRawPosition(leftX);					int horizRightHilitePos = horizAxis.numValToRawPosition(rightX);					Point leftHilitePoint = translateToScreen(horizLeftHilitePos, 0, null);					Point rightHilitePoint = translateToScreen(horizRightHilitePos, 0, null);										g.fillRect(leftHilitePoint.x, 0, rightHilitePoint.x - leftHilitePoint.x, getSize().height);										g.setColor(kDarkRed);					g.drawLine(lowPoint.x, lowPoint.y, highPoint.x, highPoint.y);					g.drawLine(lowPoint.x + 1, lowPoint.y, highPoint.x + 1, highPoint.y);					g.setColor(getForeground());				}				else					g.drawLine(lowPoint.x, lowPoint.y, highPoint.x, highPoint.y);			} catch (AxisException ex) {			}	}		protected int getHitIndex(int x, int y) {		int hitIndex = 0;		try {			Point p = translateFromScreen(x, y, null);			double xVal = horizAxis.positionToNumVal(p.x);						double minDist = Double.POSITIVE_INFINITY;			for (int i=0 ; i<pMatchWin.length ; i++) {				double dist = Math.abs(pMatchWin[i].toDouble() - xVal);				if (dist < minDist) {					minDist = dist;					hitIndex = i;				}			}		} catch (AxisException ex) {			if (ex.axisProblem == AxisException.TOO_HIGH_ERROR)				hitIndex = pMatchWin.length - 1;			else				hitIndex = 0;		}				return hitIndex;	}}	