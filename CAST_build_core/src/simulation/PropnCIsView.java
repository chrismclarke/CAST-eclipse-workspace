package simulation;import java.awt.*;import dataView.*;import distn.*;import simulationProg.*;abstract public class PropnCIsView extends DataView {	static final protected Color kDarkRed = new Color(0x990000);		static final private double kConfidenceLevel = 0.95;		protected String pKey, resultKey;	protected NumValue[] pMatchWin;	protected PropnCIXApplet applet;		protected int selectedIndex;		protected int n[];	protected int x[];	protected double ciLow[];	protected double ciHigh[];		private boolean accurateAlgorithm = false;		public PropnCIsView(DataSet theData, PropnCIXApplet applet, String pKey, String resultKey,									NumValue[] pMatchWin, int selectedIndex) {		super(theData, applet, new Insets(0, 0, 0, 0));				this.pKey = pKey;		this.resultKey = resultKey;		this.pMatchWin = pMatchWin;		this.selectedIndex = selectedIndex;		this.applet = applet;				n = new int[pMatchWin.length];		x = new int[pMatchWin.length];		ciLow = new double[pMatchWin.length];		ciHigh = new double[pMatchWin.length];	}		public void selectProb(int probIndex) {		selectedIndex = probIndex;		repaint();	}		public void setAccurateAlgorithm(boolean accurateAlgorithm) {		this.accurateAlgorithm = accurateAlgorithm;		repaint();	}		protected void findCIs() {		NumVariable pVar = (NumVariable)getVariable(pKey);		CatVariable resultVar = (CatVariable)getVariable(resultKey);		Value topLabel = resultVar.getLabel(0);				for (int i=0 ; i<pMatchWin.length ; i++)			n[i] = x[i] = 0;				ValueEnumeration pe = pVar.values();		ValueEnumeration re = resultVar.values();		while (pe.hasMoreValues()) {			double nextP = pe.nextDouble();			LabelValue nextCat = (LabelValue)re.nextValue();			int pGroup = 0;			for (int i=0 ; i<pMatchWin.length ; i++)				if (nextP == pMatchWin[i].toDouble()) {					pGroup = i;					break;				}			n[pGroup] ++;			if (nextCat == topLabel)				x[pGroup] ++;		}				for (int i=0 ; i<pMatchWin.length ; i++)			if (n[i] == 0) {				ciLow[i] = 0.0;				ciHigh[i] = 1.0;			}			else if (accurateAlgorithm) {				if (x[i] == 0)					ciLow[i] = 0.0;				else {					int lowerDF1 = 2 * (n[i] - x[i] + 1);					int lowerDF2 = 2 * x[i];					double lowerF = FTable.quantile((1.0 - kConfidenceLevel) / 2.0, lowerDF1, lowerDF2);					double tempVal = (n[i] - x[i] + 1) * lowerF;					ciLow[i] = x[i] / (x[i] + tempVal);				}								if (x[i] == n[i])					ciHigh[i] = 1.0;				else {					double upperDF1 = 2 * (x[i] + 1);					double upperDF2 = 2 * (n[i] - x[i]);					double upperF = FTable.quantile((1.0 - kConfidenceLevel) / 2.0, upperDF1, upperDF2);					double tempVal = (x[i] + 1) * upperF;					ciHigh[i] = tempVal / (n[i] - x[i] + tempVal);				}			}			else {				double p = x[i] / (double)n[i];				double twoSD = 2.0 * Math.sqrt(p * (1.0 - p) / n[i]);				ciLow[i] = Math.max(0.0, p - twoSD);				ciHigh[i] = Math.min(1.0, p + twoSD);			}	}//-----------------------------------------------------------------------------------		abstract protected int getHitIndex(int x, int y);		protected boolean needsHitToDrag() {		return true;	}		protected boolean canDrag() {		return true;	}		protected PositionInfo getPosition(int x, int y) {		int newSelection = getHitIndex(x, y);		if (newSelection != selectedIndex && newSelection >= 0)			return new IndexPosInfo(newSelection);		else			return null;	}		protected boolean startDrag(PositionInfo startInfo) {		if (startInfo != null)			applet.selectWinProb(((IndexPosInfo)startInfo).itemIndex);		return true;	}		protected void doDrag(PositionInfo fromPos, PositionInfo toPos) {		startDrag(toPos);	}		protected void endDrag(PositionInfo startPos, PositionInfo endPos) {		startDrag(endPos);		repaint();	}}