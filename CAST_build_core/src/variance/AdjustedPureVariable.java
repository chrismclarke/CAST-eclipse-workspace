package variance;import dataView.*;public class AdjustedPureVariable extends NumFunctionVariable {	private DataSet data;	private String xKey, xCatKey, residKey;	private double[] baseEffect;		private double targetMean, targetVar;		private int displayDecimals;	private boolean sourceInitialised = false;	//		initialisation when source variable changes		private double xMean, sxx, srr, sff;	private int n;		private double residScale, xScale, fScale;		public AdjustedPureVariable(String theName, DataSet data, String xKey, String xCatKey,										String residKey, double[] baseEffect, double targetMean, double targetSD,										int displayDecimals) {																	//	resid variable must have zero mean within each group		super(theName);		this.data = data;		this.xKey = xKey;		this.xCatKey = xCatKey;		this.residKey = residKey;		this.baseEffect = baseEffect;		this.targetMean = targetMean;		targetVar = targetSD * targetSD;		this.displayDecimals = displayDecimals;				initialiseXY();	}		private boolean initialiseXY() {		if (!sourceInitialised) {			NumVariable xVariable = (NumVariable)data.getVariable(xKey);			ValueEnumeration xEnum = xVariable.values();			n = 0;			double sx = 0.0;			sxx = 0.0;			while (xEnum.hasMoreValues()) {				double xVal = xEnum.nextDouble();				sx += xVal;				sxx += xVal*xVal;				n ++;			}			xMean = sx / n;			sxx -= sx * xMean;						NumVariable residVariable = (NumVariable)data.getVariable(residKey);			ValueEnumeration residEnum = residVariable.values();			srr = 0.0;			while (residEnum.hasMoreValues()) {				double residVal = residEnum.nextDouble();				srr += residVal * residVal;			}						sff = 0.0;			for (int i=0 ; i<baseEffect.length ; i++)				sff += baseEffect[i] * baseEffect[i];			sff *= n / baseEffect.length;						sourceInitialised = true;			return true;		}				return false;	}		public void setR2(double pExplained, double pNonlinear) {		residScale = Math.sqrt((1.0 - pExplained) * targetVar * n / srr);		xScale = Math.sqrt(pExplained * (1 - pNonlinear) * targetVar * n / sxx);		fScale = Math.sqrt(pExplained * pNonlinear * targetVar * n / sff);	}//--------------------------------------------------------		public boolean noteVariableChange(String key) {		if (xKey.equals(key) || residKey.equals(key)) {			sourceInitialised = false;			return true;		}		return false;	}		public int getMaxDecimals() {		return displayDecimals;	}		public int noOfValues() {		Variable xVar = (Variable)data.getVariable(xKey);		return xVar.noOfValues();	}		public Value valueAt(int index) {		initialiseXY();				NumVariable xVariable = (NumVariable)data.getVariable(xKey);		CatVariable xCatVariable = (CatVariable)data.getVariable(xCatKey);		NumVariable residVariable = (NumVariable)data.getVariable(residKey);		double xVal = xVariable.doubleValueAt(index) - xMean;				int xIndex = xCatVariable.getItemCategory(index);				double fVal = baseEffect[xIndex];		double residVal = residVariable.doubleValueAt(index);				double resultVal = targetMean + xScale * xVal + fScale * fVal + residScale * residVal;				NumValue result = new NumValue(resultVal, displayDecimals);		return result;	}}