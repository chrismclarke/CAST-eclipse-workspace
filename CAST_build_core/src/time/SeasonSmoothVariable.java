package time;import dataView.*;public class SeasonSmoothVariable extends StoredFunctVariable {	static public final int NO_LINEAR = 0;	static public final int LINEAR = 1;	static public final int NO_SEASON = 0;	static public final int SEASON = 2;	static public final int NO_EXP_SMOOTH = 0;	static public final int EXP_SMOOTH = 4;	static public final int NO_RESID = 0;	static public final int RESID = 8;	static public final int SHOW_ALL = LINEAR + SEASON + EXP_SMOOTH + RESID;		private int extraDecimals = 0;	private int noOfSeasons = 1;	private int firstValSeason = 0;		private double mean, slope, intercept;	private double seasonEffect[];	private double resid[];		private int displayFlags = SHOW_ALL;	private double expSmoothConst = 1.0;		public SeasonSmoothVariable(String theName, DataSet data, String sourceKey) {		super(theName, data, sourceKey);	}		public void setSeasonInfo(int noOfSeasons, int firstValSeason) {		this.noOfSeasons = noOfSeasons;		this.firstValSeason = firstValSeason;	}		public void setExtraDecimals(int extraDecimals) {		this.extraDecimals = extraDecimals;	}		public boolean getLinearShow() {		return (displayFlags & LINEAR) != 0;	}		public boolean getSeasonShow() {		return (displayFlags & SEASON) != 0;	}		public boolean getExpSmoothShow() {		return (displayFlags & EXP_SMOOTH) != 0;	}		public boolean getResidShow() {		return (displayFlags & RESID) != 0;	}		public double getExpSmoothConst() {		return expSmoothConst;	}		public void setLinearShow(boolean showNotHide) {		if (showNotHide != getLinearShow()) {			displayFlags = displayFlags & (SHOW_ALL - LINEAR);			if (showNotHide)				displayFlags |= LINEAR;			markChanged();		}	}		public void setSeasonShow(boolean showNotHide) {		if (showNotHide != getSeasonShow()) {			displayFlags = displayFlags & (SHOW_ALL - SEASON);			if (showNotHide)				displayFlags |= SEASON;			markChanged();		}	}		public void setExpSmoothShow(boolean showNotHide) {		if (showNotHide != getExpSmoothShow()) {			displayFlags = displayFlags & (SHOW_ALL - EXP_SMOOTH);			if (showNotHide)				displayFlags |= EXP_SMOOTH;			markChanged();		}	}		public void setResidShow(boolean showNotHide) {		if (showNotHide != getResidShow()) {			displayFlags = displayFlags & (SHOW_ALL - RESID);			if (showNotHide)				displayFlags |= RESID;			markChanged();		}	}		public void setExpSmoothConst(double expSmoothConst) {		if (expSmoothConst != this.expSmoothConst) {			this.expSmoothConst = expSmoothConst;			markChanged();		}	}//--------------------------------------------------------		protected int getDecimals() {		NumVariable sourceVar = getSourceVariable();		return sourceVar.getMaxDecimals() + extraDecimals;	}	protected int getMinInfluence(int index) {		return 0;	}		protected int getMaxInfluence(int index) {		return noOfValues() - 1;	}//--------------------------------------------------------		protected ValueEnumeration getEnumeration() {		return new SeasonSmoothEnumeration(mean, slope, intercept, seasonEffect, resid,														displayFlags, expSmoothConst, firstValSeason);	}		protected ValueEnumeration sourceEnumeration(NumVariable sourceVar) {		return sourceVar.values();	}		protected void setupSource() {		NumVariable variable = getSourceVariable();		int noOfVals = variable.noOfValues();		if (resid == null)			resid = new double[noOfVals];				ValueEnumeration val = sourceEnumeration(variable);		for (int i=0 ; i<noOfVals ; i++)			resid[i] = val.nextDouble();				int ignoreCount = noOfSeasons / 2;		seasonEffect = new double[noOfSeasons];		int seasonCount[] = new int[noOfSeasons];				MeanEnumeration me = new MeanEnumeration(sourceEnumeration(variable), noOfSeasons, true);		for (int i=0 ; i<ignoreCount ; i++)			me.nextDouble();				int season = (firstValSeason + ignoreCount) % noOfSeasons;		for (int i=ignoreCount ; i<variable.noOfValues() - ignoreCount ; i++) {			seasonEffect[season] += resid[i] - me.nextDouble();			seasonCount[season] ++;			season = (season + 1) % noOfSeasons;		}				for (int i=0 ; i<noOfSeasons ; i++)			seasonEffect[i] /= seasonCount[i];				season = firstValSeason;		double total = 0.0;		for (int i=0 ; i<noOfVals ; i++) {			resid[i] -= seasonEffect[season];		//		remove seasonal effects			total += resid[i];			season = (season + 1) % noOfSeasons;		}		mean = total / noOfVals;						//		remove mean effect		for (int i=0 ; i<noOfVals ; i++)			resid[i] -= mean;				double syt = 0.0;									//		remove linear effect		double sy = 0.0;		for (int i=0 ; i<noOfVals ; i++) {			sy += resid[i];			syt += resid[i] * i;		}		double stt = noOfVals * (noOfVals - 1) * (noOfVals + 1) / 12.0;		slope = (syt - sy * 0.5 * (noOfVals - 1)) / stt;		intercept = sy / noOfVals - slope * 0.5 * (noOfVals - 1);		for (int i=0 ; i<noOfVals ; i++)			resid[i] -= (intercept + slope * i);	}}