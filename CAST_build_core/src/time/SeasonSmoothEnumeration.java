package time;import dataView.*;class SeasonSmoothEnumeration implements ValueEnumeration {	private double mean, slope, intercept;	private double seasonEffect[];	private double resid[];		private int displayFlags;	private double expSmoothConst;	private int index = 0;	private int seasonIndex;	private double lastSmooth;		public SeasonSmoothEnumeration(double mean, double slope, double intercept,				double seasonEffect[], double resid[], int displayFlags, double expSmoothConst,				int firstSeasonIndex) {		this.mean = mean;		this.slope = slope;		this.intercept = intercept;		this.seasonEffect = seasonEffect;		this.resid = resid;		this.displayFlags = displayFlags;		this.expSmoothConst = expSmoothConst;		seasonIndex = firstSeasonIndex;	}		public boolean hasMoreValues() {		return index < resid.length;	}		public double nextDouble() {		double result = mean;		if ((displayFlags & SeasonSmoothVariable.LINEAR) != 0)			result += intercept + slope * index;		if ((displayFlags & SeasonSmoothVariable.SEASON) != 0)			result += seasonEffect[seasonIndex];					if (index == 0)			lastSmooth = resid[0];		else			lastSmooth = resid[index] * expSmoothConst + lastSmooth * (1.0 - expSmoothConst);				if ((displayFlags & SeasonSmoothVariable.RESID) != 0)			result += resid[index] - lastSmooth;		if ((displayFlags & SeasonSmoothVariable.EXP_SMOOTH) != 0) {			result += lastSmooth;		}		index++;		seasonIndex = (seasonIndex + 1) % seasonEffect.length;		return result;	}		public Value nextValue() {		return new NumValue(nextDouble());	}		public RepeatValue nextGroup() {		return new RepeatValue(nextValue(), 1);	}}