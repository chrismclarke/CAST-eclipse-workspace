package time;import dataView.*;class MedianEnumeration implements ValueEnumeration {	private ValueEnumeration e;	private int maxRunLength;	private double recent[];	private int rank[];	private int currentRunLength;		private boolean showEnds = true;		public MedianEnumeration(ValueEnumeration e, int runLength, boolean showEnds) {		this.e = e;		if ((runLength / 2) * 2 == runLength)		//		Even number			throw new RuntimeException("Error: even number of terms for running median");		maxRunLength = runLength;		recent = new double[maxRunLength];		rank = new int[maxRunLength];		currentRunLength = 0;		this.showEnds = showEnds;	}	//	public MedianEnumeration(ValueEnumeration e, int runLength) {//		this(e, runLength, true);//	}		public boolean hasMoreValues() {		return currentRunLength >= 3 || e.hasMoreValues();	}		private void setFinalRank() {		double newVal = recent[currentRunLength-1];		int numberLess = 0;		for (int i=0 ; i<currentRunLength-1 ; i++)			if (recent[i] > newVal)				rank[i]++;			else				numberLess++;		rank[currentRunLength - 1] = numberLess;	}		private double nextSource() {		return (e.hasMoreValues()) ? e.nextDouble() : Double.NaN;	}		public double nextDouble() {		double nextVal = nextSource();		if (Double.isNaN(nextVal)) {			if (currentRunLength == 0)				return Double.NaN;			else {				if (currentRunLength == 3) {					recent[0] = recent[2];					rank[0] = 0;					currentRunLength = 1;				}				else {					for (int i=2 ; i<currentRunLength ; i++) {						if (rank[i] >= rank[0])							rank[i]--;						if (rank[i] >= rank[1])							rank[i]--;					}					for (int i=0 ; i<currentRunLength-2 ; i++) {						recent[i] = recent[i+2];						rank[i] = rank[i+2];					}					currentRunLength -= 2;				}			}		}		else {			if (currentRunLength == 0) {				currentRunLength = 1;				recent[0] = nextVal;				rank[0] = 0;			}			else {				if (currentRunLength < maxRunLength && e.hasMoreValues()) {					double val2 = e.nextDouble();					recent[currentRunLength] = nextVal;					rank[currentRunLength] = currentRunLength;					currentRunLength ++;					setFinalRank();					recent[currentRunLength] = val2;					rank[currentRunLength] = currentRunLength;					currentRunLength ++;					setFinalRank();				}				else {					int deletedRank = rank[0];					for (int i=0 ; i<currentRunLength-1 ; i++) {						recent[i] = recent[i+1];						rank[i] = (rank[i+1] > deletedRank) ? rank[i+1]-1 : rank[i+1];					}					recent[currentRunLength - 1] = nextVal;					rank[currentRunLength - 1] = currentRunLength - 1;					setFinalRank();				}			}		}		if (currentRunLength < maxRunLength && !showEnds)			return Double.NaN;		int targetRank = currentRunLength / 2;		for (int i=0 ; i<currentRunLength ; i++)			if (rank[i] == targetRank)				return recent[i];		throw new RuntimeException("Error: rank does not exist");	//	this should never be thrown	}		public Value nextValue() {		return new NumValue(nextDouble());	}		public RepeatValue nextGroup() {		return new RepeatValue(nextValue(), 1);	}}