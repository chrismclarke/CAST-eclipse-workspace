package time;import dataView.*;class MeanEnumeration implements ValueEnumeration {	private ValueEnumeration e;	private double recent[];	private int maxRunLength, currentRunLength, effectiveRunLength;	private boolean oddRun;		private double total;		private boolean showEnds = true;		public MeanEnumeration(ValueEnumeration e, int runLength, boolean showEnds) {		this.e = e;		oddRun = (runLength != (runLength / 2) * 2);		maxRunLength = (oddRun ? runLength : runLength + 1);		recent = new double[maxRunLength];		currentRunLength = 0;		effectiveRunLength = 0;		this.showEnds = showEnds;	}	//	public MeanEnumeration(ValueEnumeration e, int runLength) {//		this(e, runLength, true);//	}		public boolean hasMoreValues() {		return currentRunLength >= 3 || e.hasMoreValues();	}		private double nextSource() {		return (e.hasMoreValues()) ? e.nextDouble() : Double.NaN;	}		public double nextDouble() {		double nextVal = nextSource();		if (Double.isNaN(nextVal)) {			if (currentRunLength == 0)				return Double.NaN;			else {				if (currentRunLength == 3) {					total = recent[0] = recent[2];					currentRunLength = 1;					effectiveRunLength = 1;				}				else {					if (oddRun || currentRunLength < maxRunLength) {						total -= (recent[0] + recent[1]);						effectiveRunLength -= 2;					}					else {		//	change from even to odd						total -= (recent[0] * 0.5 + recent[1] - recent[currentRunLength - 2] * 0.5);						effectiveRunLength --;					}					for (int i=0 ; i<currentRunLength-2 ; i++)						recent[i] = recent[i+2];					currentRunLength -= 2;				}			}		}		else {			if (currentRunLength == 0) {				currentRunLength = 1;				effectiveRunLength = 1;				recent[0] = nextVal;				total = nextVal;			}			else if (currentRunLength < maxRunLength && e.hasMoreValues()) {				double val2 = e.nextDouble();				recent[currentRunLength] = nextVal;				recent[currentRunLength + 1] = val2;				currentRunLength += 2;				if (oddRun || currentRunLength < maxRunLength) {					total += nextVal + val2;					effectiveRunLength += 2;				}				else {					total += nextVal + (val2 - recent[0]) * 0.5;		//	change from odd to even					effectiveRunLength ++;				}			}			else {				if (oddRun || currentRunLength < maxRunLength)					total += nextVal - recent[0];				else					total += (nextVal + recent[currentRunLength - 1] - recent[0] - recent[1]) * 0.5;				for (int i=0 ; i<currentRunLength-1 ; i++)					recent[i] = recent[i+1];				recent[currentRunLength - 1] = nextVal;			}		}		if (currentRunLength < maxRunLength && !showEnds)			return Double.NaN;		else			return total / effectiveRunLength;	}		public Value nextValue() {		return new NumValue(nextDouble());	}		public RepeatValue nextGroup() {		return new RepeatValue(nextValue(), 1);	}}