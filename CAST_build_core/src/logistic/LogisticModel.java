package logistic;import java.awt.*;import dataView.*;import axis.*;import models.*;import regn.*;public class LogisticModel extends LinearModel {	static final private int kMaxIterations = 10;	static final private double kConvergenceConst = 0.00001;		static final private double kMinProportion = 0.001;	static final private double kMaxProportion = 1.0 - kMinProportion;		private boolean autoHandleValues = true;	private double lowHandleValue, highHandleValue;			public LogisticModel(String name, DataSet data, String xKey, NumValue b0, NumValue b1) {		super(name, data, xKey, b0, b1);	}		public LogisticModel(String name, DataSet data, String xKey, String params) {		super(name, data, xKey, params);	}		public LogisticModel(String name, DataSet data, String xKey) {		//		only for situations where parameters														//		are set by ML immediately after		super(name, data, xKey);	}		public void setManualHandles(double lowHandle, double highHandle) {		autoHandleValues = false;		lowHandleValue = lowHandle;		highHandleValue = highHandle;	}		public double doMLIteration(int[][] jointCounts, double[] xValues, double[] linearPredictor,																								double[] fittedProb) {		LeastSquares lsCalc = new LeastSquares(3);		double dataRow[] = new double[3];		for (int i=0 ; i<xValues.length ; i++) {			double x = xValues[i];			int success = jointCounts[0][i];			int total = success + jointCounts[1][i];			if (!Double.isNaN(x)) {				dataRow[0] = 1.0;				dataRow[1] = x;				double w = total * fittedProb[i] * (1.0 - fittedProb[i]);				dataRow[2] = linearPredictor[i] + (success - fittedProb[i] * total) / w;				lsCalc.addDataRow(dataRow, 1.0 / w);			}		}		double coeff[] = lsCalc.getCoefficients();		b0.setValue(coeff[0]);		b1.setValue(coeff[1]);				double deviance = 0.0;		for (int i=0 ; i<xValues.length ; i++) {			double x = xValues[i];			linearPredictor[i] = b0.toDouble() + b1.toDouble() * x;			fittedProb[i] = 1.0 - 1.0 / (1.0 + Math.exp(linearPredictor[i]));			int success = jointCounts[0][i];			int failure = jointCounts[1][i];			double propnSuccess = ((double)success) / (success + failure);			deviance += 2.0 * (success * Math.log(propnSuccess / fittedProb[i])									+ failure * Math.log((1.0 - propnSuccess) / (1.0 - fittedProb[i])));		}				return deviance;	}		public void setMLParams(int[][] jointCounts, double[] xValues, int intDecs,													int slopeDecs) {		int totalSuccess = 0;		int totalFailure = 0;		for (int i=0 ; i<xValues.length ; i++) {			totalSuccess += jointCounts[0][i];			totalFailure += jointCounts[1][i];		}		double marginalProp = ((double)totalSuccess) / (totalSuccess + totalFailure);				b1 = new NumValue(0.0, slopeDecs);		b0 = new NumValue(Math.log(marginalProp / (1.0 - marginalProp)), intDecs);				double[] linearPredictor = new double[xValues.length];		double[] fittedProb = new double[xValues.length];		double deviance = 0.0;		for (int i=0 ; i<xValues.length ; i++) {			linearPredictor[i] = b0.toDouble();			fittedProb[i] = marginalProp;			int success = jointCounts[0][i];			int failure = jointCounts[1][i];			double propnSuccess = ((double)success) / (success + failure);			deviance += 2.0 * (success * Math.log(propnSuccess / marginalProp)									+ failure * Math.log((1.0 - propnSuccess) / (1.0 - marginalProp)));		}				for (int i=0 ; i<kMaxIterations ; i++) {			double nextDeviance = doMLIteration(jointCounts, xValues, linearPredictor, fittedProb);			if (Math.abs(deviance - nextDeviance) < kConvergenceConst)				break;			deviance = nextDeviance;		}		return;	}		public void setMLParams(int[][] jointCounts, double[] xValues) {		int intDecs = b0.decimals;		int slopeDecs = b1.decimals;		setMLParams(jointCounts, xValues, intDecs, slopeDecs);	}		protected boolean positiveCurvature() {		//		unfortunately this varies, depending on x		return true;	}		public double evaluateMean(double x) {		double linearPart = b0.toDouble() + x * b1.toDouble();		double exponPart = Math.exp(linearPart);		return exponPart / (1.0 + exponPart);	}		protected double inverseEvaluate(double y, boolean lowNotHigh) {		return (Math.log(y / (1.0 - y)) - b0.toDouble()) / b1.toDouble();	}		private void checkHandleValues(NumCatAxis horizAxis) {		if (autoHandleValues) {			double xMin = horizAxis.minOnAxis;			double xMax = horizAxis.maxOnAxis;			double range = xMax - xMin;			lowHandleValue = xMin + range / 4.0;			highHandleValue = xMax - range / 4.0;		}	}		public Point[] getHandles(DataView view, NumCatAxis horizAxis, NumCatAxis vertAxis) {		PositionFinder finder = new PositionFinder(view, horizAxis, vertAxis);				checkHandleValues(horizAxis);				Point[] p = new Point[2];		p[0] = finder.findPoint(lowHandleValue, evaluateMean(lowHandleValue), null);		p[1] = finder.findPoint(highHandleValue, evaluateMean(highHandleValue), null);		return p;	}		public void setHandle(int index, double newValue, NumCatAxis horizAxis) {		newValue = Math.max(kMinProportion, Math.min(kMaxProportion, newValue));				checkHandleValues(horizAxis);				double y0 = evaluateMean(lowHandleValue);		double y1 = evaluateMean(highHandleValue);		switch (index) {			case 0:				y0 = newValue;				break;			case 1:				y1 = newValue;				break;			default:				;		}		double logit0 = Math.log(y0 / (1.0 - y0));		double logit1 = Math.log(y1 / (1.0 - y1));				b1.setValue((logit1 - logit0) / (highHandleValue - lowHandleValue));		b0.setValue(logit0 - b1.toDouble() * lowHandleValue);	}		public void drawMean(Graphics g, DataView view, NumCatAxis horizAxis, NumCatAxis vertAxis) {		PositionFinder finder = new PositionFinder(view, horizAxis, vertAxis);				if (b1.toDouble() == 0.0)			drawMonotonic(finder.xMin, finder.xMax, g, finder);		else {			double centre = -b0.toDouble() / b1.toDouble();			if (centre < finder.xMin | centre > finder.xMax)				drawMonotonic(finder.xMin, finder.xMax, g, finder);			else {				drawMonotonic(finder.xMin, centre, g, finder);				drawMonotonic(centre, finder.xMax, g, finder);			}		}	}}