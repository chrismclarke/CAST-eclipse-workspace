package loess;import java.awt.*;import dataView.*;import axis.*;public class LoessSmoothVariable extends NumFunctionVariable {	static final private int kBigDecimals = 10;	//	static final private double kMinHitFraction = 0.02;											//		min x-distance for hits as a fraction of axis length		private int windowPoints;		private double xTrans[];	private double yTrans[];	private double xKnot[];	private double slope[];	private double intercept[];		private String xKey, yKey;	private NumVariable xVariable, yVariable;	private NumCatAxis xAxis, yAxis;		public LoessSmoothVariable(String theName, DataSet data, String xKey, String yKey) {		super(theName);		this.xKey = xKey;		this.yKey = yKey;		xVariable = (NumVariable)data.getVariable(xKey);		yVariable = (NumVariable)data.getVariable(yKey);	}		public int getWindowPoints() {		return windowPoints;	}		public void setAxes(NumCatAxis xAxis, NumCatAxis yAxis) {		this.xAxis = xAxis;		this.yAxis = yAxis;	}		public void initialise(int windowPoints) {		if (windowPoints < 2)			return;		this.windowPoints = windowPoints;				int n = xVariable.noOfValues();		int noOfKnots = n - windowPoints;				NumValue sortedX[] = xVariable.getSortedData();		int xIndex[] = xVariable.getSortedIndex();				if (xKnot == null) {			xTrans = new double[n];			yTrans = new double[n];			xKnot = new double[n - 1];			slope = new double[n];			intercept = new double[n];		}				double sx = 0.0;		double sxx = 0.0;		double sy = 0.0;		double sxy = 0.0;		for (int i=0 ; i<windowPoints ; i++) {			double x = xAxis.transform(sortedX[i].toDouble());			xTrans[i] = x;			double y = yAxis.transform(yVariable.doubleValueAt(xIndex[i]));			yTrans[i] = y;			sx += x;			sxx += x * x;			sy += y;			sxy += x * y;		}		double xMin = xTrans[0];		double xMax = xTrans[windowPoints-1];				double nInv = 1.0 / windowPoints;		for (int i=0 ; i<noOfKnots+1 ; i++) {			if (xMax > xMin) {				slope[i] = (sxy - sx * sy * nInv) / (sxx - sx * sx * nInv);				intercept[i] = (sy - slope[i] * sx) * nInv;			}			else {				slope[i] = 0.0;				intercept[i] = sy * nInv;			}						if (i < noOfKnots) {				double x = xAxis.transform(sortedX[windowPoints + i].toDouble());				xTrans[windowPoints + i] = x;				double y = yAxis.transform(yVariable.doubleValueAt(xIndex[windowPoints + i]));				yTrans[windowPoints + i] = y;				double xDrop = xTrans[i];				double yDrop = yTrans[i];								xKnot[i] = (x + xDrop) * 0.5;									sx += x - xDrop;				sxx += x * x - xDrop * xDrop;				sy += y - yDrop;				sxy += x * y - xDrop * yDrop;								xMax = x;				xMin = xTrans[i+1];			}		}	}		private Point drawLineTo(Graphics g, DataView view, Point oldPoint, double xTrans,																			double yTrans, Point thePoint) {		int horizPos = axisPosFromTransformed(xTrans, xAxis);		int vertPos = axisPosFromTransformed(yTrans, yAxis);				thePoint = view.translateToScreen(horizPos, vertPos, thePoint);		if (oldPoint != null)			g.drawLine(oldPoint.x, oldPoint.y, thePoint.x, thePoint.y);				return thePoint;	}		private Point getOffScreenPoint(double b0, double b1, DataView view, boolean highNotLow) {		double minXTrans = xAxis.transform(xAxis.minOnAxis);		double maxXTrans = xAxis.transform(xAxis.maxOnAxis);		double xAxisTransWidth = maxXTrans - minXTrans;				double xTransDraw = highNotLow ? (maxXTrans + 0.5 * xAxisTransWidth)													: (minXTrans - 0.5 * xAxisTransWidth);		double yTransDraw = b0 + b1 * xTransDraw;				int xPos = highNotLow ? (int)Math.round(1.5 * xAxis.getAxisLength())										: (int)Math.round(-0.5 * xAxis.getAxisLength());				int yPos = axisPosFromTransformed(yTransDraw, yAxis);				return view.translateToScreen(xPos, yPos, null);	}		private int axisPosFromTransformed(double val, NumCatAxis axis) {		double minTrans = axis.transform(axis.minOnAxis);		double maxTrans = axis.transform(axis.maxOnAxis);//		double axisTransWidth = maxTrans - minTrans;		return (int)Math.round((val - minTrans) / (maxTrans - minTrans)																						* axis.getAxisLength());	}		public void drawCurve(Graphics g, DataView view) {		int n = xVariable.noOfValues();//		NumValue sortedX[] = xVariable.getSortedData();		int noOfKnots = n - windowPoints;				double b1 = slope[0];		double b0 = intercept[0];		Point oldPoint = getOffScreenPoint(b0, b1, view, false);		Point newPoint = null;				int firstXIndex = 0;		for (int knotIndex=0 ; knotIndex<noOfKnots ; knotIndex++) {			b0 = intercept[knotIndex];			b1 = slope[knotIndex];			int lastXIndex = firstXIndex - 1;			while (lastXIndex < n-1 && xTrans[lastXIndex+1] < xKnot[knotIndex])				lastXIndex ++;			if (lastXIndex >= firstXIndex) {				double x = xTrans[firstXIndex];				double y = b0 + b1 * x;								Point temp = oldPoint;				oldPoint = drawLineTo(g, view, oldPoint, x, y, newPoint);				newPoint = temp;								if (lastXIndex > firstXIndex && knotIndex < noOfKnots) {					x = xTrans[lastXIndex];					y = b0 + b1 * x;					temp = oldPoint;					oldPoint = drawLineTo(g, view, oldPoint, x, y, newPoint);					newPoint = temp;				}				firstXIndex = lastXIndex + 1;			}		}		b0 = intercept[noOfKnots];		b1 = slope[noOfKnots];		double lastX = xTrans[firstXIndex];		double lastY = b0 + b1 * lastX;		Point temp = oldPoint;		oldPoint = drawLineTo(g, view, oldPoint, lastX, lastY, newPoint);		newPoint = temp;				newPoint = getOffScreenPoint(b0, b1, view, true);		g.drawLine(oldPoint.x, oldPoint.y, newPoint.x, newPoint.y);	}		public void drawLineForX(Graphics g, DataView view, int index) {		int n = xVariable.noOfValues();		int noOfKnots = n - windowPoints;				double selectedX = xAxis.transform(xVariable.doubleValueAt(index));				int knotIndex = 0;		while (knotIndex < noOfKnots && selectedX > xKnot[knotIndex])			knotIndex ++;		double b0 = intercept[knotIndex];		double b1 = slope[knotIndex];				Point lowPoint = getOffScreenPoint(b0, b1, view, false);		Point highPoint = getOffScreenPoint(b0, b1, view, true);		g.drawLine(lowPoint.x, lowPoint.y, highPoint.x, highPoint.y);	}		public int minInfluenceIndex(int xIndex) {		int n = xVariable.noOfValues();		NumValue sortedX[] = xVariable.getSortedData();		int sortedIndex = xVariable.indexToRank(xIndex);		double selectedX = sortedX[sortedIndex].toDouble();		int minIndex = sortedIndex;		int maxIndex = sortedIndex;		for (int i=1 ; i<windowPoints ; i++)			if (minIndex == 0)				maxIndex++;			else if (maxIndex == n-1)				minIndex --;			else if (selectedX - sortedX[minIndex-1].toDouble() < sortedX[maxIndex+1].toDouble() - selectedX)				minIndex--;			else				maxIndex ++;		return minIndex;	}//--------------------------------------------------------		public int getMaxDecimals() {		return kBigDecimals;	}		public int noOfValues() {		return xVariable.noOfValues();	}		public Value valueAt(int index) {		int n = xVariable.noOfValues();		int noOfKnots = n - windowPoints;		double x = xAxis.transform(xVariable.doubleValueAt(index));				int knotIndex = 0;		while (knotIndex < noOfKnots && x > xKnot[knotIndex])			knotIndex ++;		double b0 = intercept[knotIndex];		double b1 = slope[knotIndex];				NumValue result = new NumValue(yAxis.inverseTransform(b0 + b1 * x), kBigDecimals);		return result;	}//--------------------------------------------------------		public boolean noteVariableChange(String key) {		if (xKey.equals(key) || yKey.equals(key)) {			initialise(windowPoints);			return true;		}		return false;	}}