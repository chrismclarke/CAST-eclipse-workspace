package loess;import java.awt.*;import dataView.*;import axis.*;public class TransPIFinder {	private double intercept, slope, ts, nInv, xMean, sxx;	private NumCatAxis xAxis, yAxis;	private NumCatAxis xCalcAxis, yCalcAxis;	private DataView view;		double maxLinearError, maxXDifference;		private int nPoints = 1;			//		first point is not counted otherwise	private int[] xCoord, yCoord;		private boolean countMode = true;		public TransPIFinder(double intercept, double slope, double ts, double nInv,					double xMean, double sxx, DataView view, NumCatAxis xAxis, NumCatAxis yAxis,					NumCatAxis xCalcAxis, NumCatAxis yCalcAxis) {		this.intercept = intercept;		this.slope = slope;		this.ts = ts;		this.nInv = nInv;		this.xMean = xMean;		this.sxx = sxx;		this.view = view;		this.xAxis = xAxis;		this.yAxis = yAxis;		this.xCalcAxis = xCalcAxis;		this.yCalcAxis = yCalcAxis;				maxLinearError = (yAxis.transform(yAxis.maxOnAxis)														- yAxis.transform(yAxis.minOnAxis)) * 0.002;		double xDisplayMin = xAxis.transform(xAxis.minOnAxis);		double xDisplayMax = xAxis.transform(xAxis.maxOnAxis);		maxXDifference = (xDisplayMax - xDisplayMin) * 0.001;				double xSlop = (xDisplayMax - xDisplayMin) * 0.05;		xDisplayMin -= xSlop;		xDisplayMax += xSlop;				testMonotonic(xDisplayMin, xDisplayMax);				countMode = false;		xCoord = new int[nPoints];		yCoord = new int[nPoints];				Point p0 = findPoint(xDisplayMin, evaluateBound(xDisplayMin), null);		xCoord[0] = p0.x;		yCoord[0] = p0.y;		nPoints = 1;				testMonotonic(xDisplayMin, xDisplayMax);	}		private Point findPoint(double x, double y, Point thePoint) {				return view.translateToScreen(xAxis.numTransValToRawPosition(x),														yAxis.numTransValToRawPosition(y), thePoint);	}		public int[] getXCoords() {		return xCoord;	}		public int[] getYCoords() {		return yCoord;	}		private double evaluateBound(double xDisplay) {		double xTrans = (xAxis == xCalcAxis) ? xDisplay									: xCalcAxis.transform(xAxis.inverseTransform(xDisplay));				double yTrans = intercept + slope * xTrans								+ ts * Math.sqrt(nInv + (xTrans - xMean) * (xTrans - xMean) / sxx);		return (yAxis == yCalcAxis) ? yTrans												: yAxis.transform(yCalcAxis.inverseTransform(yTrans));	}		private boolean nearlyLinear(double y0, double yMid, double y1) {		if (Double.isNaN(y0) || Double.isInfinite(y0)											|| Double.isNaN(y1) || Double.isInfinite(y1))			return false;				return Math.abs(yMid - (y0 + y1) * 0.5) < maxLinearError;	}		private boolean sameX(double x0, double x1) {		return (x1 - x0) <= maxXDifference;	}		private void testSegment(double x0, double y0, double x1, double y1, Point p1) {		if (sameX(x0, x1))			return;		//		System.err.println("x0 = " + x0 + ", y0 = " + y0 + ", x1 = " + x1 + ", y1 = " + y1);//		try {//			Thread.sleep(500);//		} catch (InterruptedException e) {//		}				double xMid = (x0 + x1) * 0.5;		double yMid = evaluateBound(xMid);				if (nearlyLinear(y0, yMid, y1) || sameX(x0, x1)) {			if (countMode)				nPoints ++;			else {				p1 = findPoint(x1, y1, p1);				xCoord[nPoints] = p1.x;				yCoord[nPoints ++] = p1.y;			}		}		else {			testSegment(x0, y0, xMid, yMid, p1);			testSegment(xMid, yMid, x1, y1, p1);		}	}		private void testMonotonic(double xDisplayLow, double xDisplayHigh) {		double x0 = xDisplayLow;		double y0 = evaluateBound(x0);		double x1 = xDisplayHigh;		double y1 = evaluateBound(x1);				Point p1 = new Point(0, 0);		//		System.err.println("xLow = " + xLow + ", xHigh = " + xHigh);				testSegment(x0, y0, x1, y1, p1);	}}