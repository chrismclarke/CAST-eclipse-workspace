package mixture;import java.awt.*;import coreGraphics.*;public class MixtureGridDrawer {	private int axisSteps;		public double[][] fitValue;		private ColourMap colourMap;		private int[][] horizGridCoord;	private int[][] vertGridCoord;		public MixtureGridDrawer(int axisSteps) {		this.axisSteps = axisSteps;				fitValue = new double[axisSteps + 1][];		for (int i=0 ; i<=axisSteps ; i++)			fitValue[i] = new double[axisSteps + 1 - i];	}		public void setColourMap(ColourMap colourMap) {		this.colourMap = colourMap;	}		public ColourMap getColourMap() {		return colourMap;	}		public void findFittedValues(MixtureModel model) {		double x[] = new double[3];		for (int i=0 ; i<=axisSteps ; i++) {			x[0] = i / (double)axisSteps;			for (int j=0 ; j<=axisSteps-i ; j++) {				x[1] = j / (double)axisSteps;				x[2] = 1.0 - x[0] - x[1];				fitValue[i][j] = model.evaluateMean(x);			}		}	}		public void setGridCoords(int[][] horizGridCoord, int[][] vertGridCoord) {		this.horizGridCoord = horizGridCoord;		this.vertGridCoord = vertGridCoord;	}		public double getFitAt(double r, double s, double t, MixtureModel model,																																			double[] xTemp) {		xTemp[0] = r;		xTemp[1] = s;		xTemp[2] = t;		return model.evaluateMean(xTemp);	}		public Color getColor(double r, double s, double t, MixtureModel model, double[] xTemp) {		if (colourMap == null)			return Color.lightGray;					double fit = getFitAt(r, s, t, model, xTemp);				return colourMap.getColour(fit);	}		private void shadeBaseRCell(Graphics g, int iR, int jS,														MixtureModel model, int[] tempPolyHoriz, int[] tempPolyVert,														double contourValue, double[] xTemp) {		double r = (iR + 1.0 / 3.0) / axisSteps;		double s = (jS + 1.0 / 3.0) / axisSteps;		double t = 1.0 - r - s;		Color c = getColor(r, s, t, model, xTemp);				g.setColor(c);		tempPolyHoriz[3] = tempPolyHoriz[0] = horizGridCoord[iR][jS];		tempPolyHoriz[1] = horizGridCoord[iR + 1][jS];		tempPolyHoriz[2] = horizGridCoord[iR][jS + 1];		tempPolyVert[3] = tempPolyVert[0] = vertGridCoord[iR][jS];		tempPolyVert[1] = vertGridCoord[iR + 1][jS];		tempPolyVert[2] = vertGridCoord[iR][jS + 1];		g.fillPolygon(tempPolyHoriz, tempPolyVert, 4);				g.setColor(Color.black);		drawCellContour(g, iR, jS, iR+1, jS, iR, jS+1, model, contourValue);	}		private void shadePointRCell(Graphics g, int iR, int jS,														MixtureModel model, int[] tempPolyHoriz, int[] tempPolyVert,														double contourValue, double[] xTemp) {		double r = (iR + 2.0 / 3.0) / axisSteps;		double s = (jS - 1.0 / 3.0) / axisSteps;		double t = 1.0 - r - s;		Color c = getColor(r, s, t, model, xTemp);				g.setColor(c);		tempPolyHoriz[3] = tempPolyHoriz[0] = horizGridCoord[iR][jS];		tempPolyHoriz[1] = horizGridCoord[iR + 1][jS - 1];		tempPolyHoriz[2] = horizGridCoord[iR + 1][jS];		tempPolyVert[3] = tempPolyVert[0] = vertGridCoord[iR][jS];		tempPolyVert[1] = vertGridCoord[iR + 1][jS - 1];		tempPolyVert[2] = vertGridCoord[iR + 1][jS];		g.fillPolygon(tempPolyHoriz, tempPolyVert, 4);				g.setColor(Color.black);		drawCellContour(g, iR, jS, iR+1, jS-1, iR+1, jS, model, contourValue);	}		private void joinFaces(int i0, int j0, int i1, int j1, int i2, int j2,																												double contourValue, Graphics g) {		double fit0 = fitValue[i0][j0];		double fit1 = fitValue[i1][j1];		double fit2 = fitValue[i2][j2];		double propn01 = (contourValue - fit0) / (fit1 - fit0);				int horiz1 = (int)Math.round(horizGridCoord[i0][j0]														+ propn01 * (horizGridCoord[i1][j1] - horizGridCoord[i0][j0]));		int vert1 = (int)Math.round(vertGridCoord[i0][j0]														+ propn01 * (vertGridCoord[i1][j1] - vertGridCoord[i0][j0]));						double propn12 = (contourValue - fit1) / (fit2 - fit1);				int horiz2 = (int)Math.round(horizGridCoord[i1][j1]														+ propn12 * (horizGridCoord[i2][j2] - horizGridCoord[i1][j1]));		int vert2 = (int)Math.round(vertGridCoord[i1][j1]														+ propn12 * (vertGridCoord[i2][j2] - vertGridCoord[i1][j1]));		g.drawLine(horiz1, vert1, horiz2, vert2);	}		private void drawCellContour(Graphics g, int i0, int j0, int i1, int j1, int i2, int j2, 																				MixtureModel model, double contourValue) {		if (Double.isNaN(contourValue))			return;		boolean above0 = contourValue < fitValue[i0][j0];		boolean above1 = contourValue < fitValue[i1][j1];		boolean above2 = contourValue < fitValue[i2][j2];				boolean between01 = above0 != above1;		boolean between12 = above1 != above2;		boolean between02 = above0 != above2;				if (!between01 && !between12 && !between02)			return;				if (between01 && between02)				joinFaces(i1, j1, i0, j0, i2, j2, contourValue, g);		else if (between01 && between12)				joinFaces(i0, j0, i1, j1, i2, j2, contourValue, g);		else if (between02 && between12)				joinFaces(i0, j0, i2, j2, i1, j1, contourValue, g);	}		public void shadeSurface(Graphics g, MixtureModel model, double contourValue,																									int frontPointIndex, int backPointIndex) {		int tempPolyHoriz[] = new int[4];		int tempPolyVert[] = new int[4];		double xTemp[] = new double[3];		if (frontPointIndex == 0) {		//	loop from R = 0 to 1			for (int iR=0 ; iR<axisSteps ; iR++) {				if (backPointIndex == 1) {					for (int jS=(axisSteps-iR-1) ; jS>=0 ; jS--)		//	loop for jS down to 0						shadeBaseRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					for (int jS=(axisSteps-iR-1) ; jS>0 ; jS--)		//	loop for jS down to 1						shadePointRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}				else {					for (int jS=0 ; jS<(axisSteps-iR) ; jS++)		//	loop for jS up from 0						shadeBaseRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					for (int jS=1 ; jS<(axisSteps-iR) ; jS++)		//	loop for jS up from 1						shadePointRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}			}		}		else if (frontPointIndex == 1) {		//	loop from S = 0 to 1			for (int jS=0 ; jS<axisSteps ; jS++) {				if (backPointIndex == 0) {					for (int iR=(axisSteps-jS-1) ; iR>=0 ; iR--)		//	loop for iR down to 0						shadeBaseRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					if (jS > 0)						for (int iR=(axisSteps-jS-1) ; iR>=0 ; iR--)		//	loop for iR down to 0							shadePointRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}								else {		//	loop for R up from 0					for (int iR=0 ; iR<(axisSteps-jS) ; iR++)		//	loop for iR up from 0						shadeBaseRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					if (jS > 0)						for (int iR=0 ; iR<(axisSteps-jS) ; iR++)		//	loop for iR up from 0							shadePointRCell(g, iR, jS, model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}			}		}		else {		//	loop from T = 0 to 1			for (int kT=0 ; kT<axisSteps ; kT++) {				if (backPointIndex == 0) {					for (int iR=(axisSteps-kT-1) ; iR>=0 ; iR--)		//	loop for R down to 0						shadeBaseRCell(g, iR, (axisSteps - kT - iR - 1), model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					for (int iR=(axisSteps-kT-2) ; iR>=0 ; iR--)		//	loop for R down to 0						shadePointRCell(g, iR, (axisSteps - kT - iR - 1), model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}								else {					for (int iR=0 ; iR<(axisSteps-kT) ; iR++)		//	loop for R up from 0						shadeBaseRCell(g, iR, (axisSteps - kT - iR - 1), model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);					for (int iR=0 ; iR<(axisSteps-kT-1) ; iR++)		//	loop for R up from 0						shadePointRCell(g, iR, (axisSteps - kT - iR - 1), model, tempPolyHoriz, tempPolyVert, contourValue, xTemp);				}			}		}	}	/*	public void frameSurface(Graphics g) {		for (int i=0 ; i<=axisSteps ; i++)			for (int j=0 ; j<axisSteps ; j++)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i][j + 1], vertGridCoord[i][j + 1]);				for (int i=0 ; i<axisSteps ; i++)			for (int j=0 ; j<=axisSteps ; j++)				g.drawLine(horizGridCoord[i][j], vertGridCoord[i][j],																	horizGridCoord[i + 1][j], vertGridCoord[i + 1][j]);			}*/		public void drawContour(Graphics g, MixtureModel model, double contourValue) {		for (int iR=0 ; iR<axisSteps ; iR++) {			for (int jS=0 ; jS<(axisSteps-iR) ; jS++)		//	loop for jS up from 0				drawCellContour(g, iR, jS, iR+1, jS, iR, jS+1, model, contourValue);			for (int jS=1 ; jS<(axisSteps-iR) ; jS++)		//	loop for jS up from 1				drawCellContour(g, iR, jS, iR+1, jS-1, iR+1, jS, model, contourValue);		}	}		public void outlineSurface(Graphics g) {		for (int iR=0 ; iR<axisSteps ; iR++)			g.drawLine(horizGridCoord[iR][0], vertGridCoord[iR][0],																	horizGridCoord[iR + 1][0], vertGridCoord[iR + 1][0]);				for (int iR=0 ; iR<axisSteps ; iR++)			g.drawLine(horizGridCoord[iR][axisSteps - iR], vertGridCoord[iR][axisSteps - iR],										horizGridCoord[iR + 1][axisSteps - iR - 1], vertGridCoord[iR + 1][axisSteps - iR - 1]);				for (int jS=0 ; jS<axisSteps ; jS++)			g.drawLine(horizGridCoord[0][jS], vertGridCoord[0][jS],																	horizGridCoord[0][jS + 1], vertGridCoord[0][jS + 1]);	}	}