package sport;import dataView.*;public class LeagueResultsVariable extends CoreVariable implements SampleInterface {	static final public int KEEP_TIES = 0;	static final public int RESOLVE_TIES = 1;		protected RandomResult generator;	private long currentSeed, nextSeed;		protected double drawProb, team0Prob;	private LabelValue[] teamName;		protected int noOfTeams, noOfRounds;	private int result[][][];	//		result[k][i][j] = points gained by team i at home										//		against team j in round k										//		result[k][i][i] = 0		private int adjustment = KEEP_TIES;		private int homePoints[];	private int awayPoints[];	private double totalPoints[];	private double tieAdjustment[];		private int indexFromRank[];	private int topFinalsRank[] = new int[4];		static private String[] generateTeamNames(int noOfTeams) {		String[] result = new String[noOfTeams];		for (int i=0 ; i<noOfTeams ; i++)			result[i] = String.valueOf((char)('A' + i));		return result;	}		public LeagueResultsVariable(String theName, String[] teamNameString, int noOfRounds,								RandomResult generator, double drawProb, double team0Prob) {		super(theName);		this.noOfTeams = teamNameString.length;		this.drawProb = drawProb;		this.team0Prob = team0Prob;		teamName = new LabelValue[noOfTeams];		for (int i=0 ; i<noOfTeams ; i++)			teamName[i] = new LabelValue(teamNameString[i]);		homePoints = new int[noOfTeams];		awayPoints = new int[noOfTeams];		totalPoints = new double[noOfTeams];		tieAdjustment = new double[noOfTeams];		this.generator = generator;		createResultsArray(noOfRounds);	}		public LeagueResultsVariable(String theName, int noOfTeams, int noOfRounds,								RandomResult generator, double drawProb, double team0Prob) {		this(theName, generateTeamNames(noOfTeams), noOfRounds, generator, drawProb, team0Prob);	}		public void setAdjustmentType(int adjustment) {		this.adjustment = adjustment;	}		public void setTeam0Prob(double newProb) {		team0Prob = newProb;	}	public double getTeam0Prob() {		return team0Prob;	}		public void setSampleSize(int n) {		if (result.length != n)			createResultsArray(n);	}		private void createResultsArray(int noOfRounds) {		this.noOfRounds = noOfRounds;		result = new int[noOfRounds][noOfTeams][noOfTeams];		clearSample();	}		protected void resolveTies() {		if (adjustment != KEEP_TIES)			for (int i=0 ; i<noOfTeams ; i++)				tieAdjustment[i] = generator.nextDouble() * 0.1;	}		public long generateNextSample() {		currentSeed = nextSeed;		generator.setSeed(nextSeed);		for (int i=0 ; i<noOfRounds ; i++)			generator.generateRound(result[i], this);		resolveTies();		summarisePoints();		sortLeague();		doFinals();		nextSeed = generator.nextLong();		return currentSeed;	}		public boolean setSampleFromSeed(long newSeed) {		if (currentSeed == newSeed)			return false;		currentSeed = newSeed;		generator.setSeed(newSeed);		for (int i=0 ; i<noOfRounds ; i++)			generator.generateRound(result[i], this);		resolveTies();		summarisePoints();		sortLeague();		doFinals();		return true;	}		public void setNextSeed(long nextSeed) {		//	only used when setting up exercise with fixed seed		this.nextSeed = nextSeed;	}		public void clearSample() {		for (int i=0 ; i<noOfRounds ; i++)			for (int j=0 ; j<noOfTeams ; j++)				for (int k=0 ; k<noOfTeams ; k++)					result[i][j][k] = -1;		for (int i=0 ; i<noOfTeams ; i++) {			homePoints[i] = 0;			awayPoints[i] = 0;			totalPoints[i] = 0.0;		}	}		public void setResultProbs(int homeTeam, int awayTeam, double[] probs) {		probs[1] = drawProb;		if (homeTeam == 0)			probs[0] = team0Prob;		else if (awayTeam == 0)			probs[0] = 1.0 - drawProb - team0Prob;		else			probs[0] = 0.5 * (1.0 - drawProb);	}		public LabelValue[] getTeamNames() {		return teamName;	}		public int[][][] getResults() {		return result;	}		public void summarisePoints() {		for (int i=0 ; i<noOfTeams ; i++)			awayPoints[i] = 0;		for (int i=0 ; i<noOfTeams ; i++) {			homePoints[i] = 0;			for (int j=0 ; j<noOfTeams ; j++)				for (int k=0 ; k<result.length ; k++)					if (i != j && result[k][i][j] >= 0) {						int score = result[k][i][j];						homePoints[i] += score;						int awayScore = (score == RandomResult.WIN_SCORE) ? RandomResult.LOSE_SCORE									: (score == RandomResult.LOSE_SCORE) ? RandomResult.WIN_SCORE									: score;						awayPoints[j] += awayScore;					}		}				for (int i=0 ; i<noOfTeams ; i++)			totalPoints[i] = (homePoints[i] + awayPoints[i]) + tieAdjustment[i];	}		private void sortLeague() {		int noOfTeams = teamName.length;		if (indexFromRank == null || indexFromRank.length != noOfTeams)			indexFromRank = new int[noOfTeams];		for (int i=0 ; i<noOfTeams ; i++)			indexFromRank[i] = i;				for (int i=0 ; i<noOfTeams-1 ; i++)			for (int j=i+1 ; j<noOfTeams ; j++)				if (totalPoints[indexFromRank[i]] < totalPoints[indexFromRank[j]]) {					int temp = indexFromRank[i];					indexFromRank[i] = indexFromRank[j];					indexFromRank[j] = temp;				}	}		private void doFinals() {		int team0Index = indexFromRank[0];		int team1Index = indexFromRank[1];		int team2Index = indexFromRank[2];		int team3Index = indexFromRank[3];		boolean team0SemiWin = generator.homeTeamWins(team0Index, team3Index, this);		boolean team1SemiWin = generator.homeTeamWins(team1Index, team2Index, this);		topFinalsRank[0] = team0SemiWin ? team0Index : team1SemiWin ? team1Index : team2Index;		topFinalsRank[1] = team0SemiWin ? (team1SemiWin ? team1Index : team2Index) : team3Index;		topFinalsRank[2] = team0SemiWin ? (team1SemiWin ? team2Index : team1Index) : team0Index;		topFinalsRank[3] = team0SemiWin ? team3Index : team1SemiWin ? team2Index : team1Index;		boolean team0FinalWin = generator.homeTeamWins(topFinalsRank[0], topFinalsRank[1], this);		if (!team0FinalWin) {			int temp = topFinalsRank[0];			topFinalsRank[0] = topFinalsRank[1];			topFinalsRank[1] = temp;		}	}		public double[] getFinalPoints() {		return totalPoints;	}		public int[] getHomePoints() {		return homePoints; 	}		public int[] getAwayPoints() {		return awayPoints; 	}		public int[] getRankIndices() {		return indexFromRank;	}		public int[] getFinalsRankIndices() {		return topFinalsRank;	}		public boolean dataExists() {		int totalPts = 0;		for (int i=0 ; i<noOfTeams ; i++)			totalPts += homePoints[i] + awayPoints[i];		return totalPts > 0;	}}