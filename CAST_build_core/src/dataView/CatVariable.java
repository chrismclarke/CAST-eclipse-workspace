package dataView;import java.util.*;import java.awt.*;public class CatVariable extends Variable implements CatVariableInterface {	private Vector catLabels = new Vector(8);	private Vector originalIndex = null;		public CatVariable(String theName) {		super(theName);	}		public CatVariable(String theName, boolean usesGroups) {		super(theName, usesGroups);	}		public void readLabels(String labelString) {		catLabels.removeAllElements();		LabelEnumeration theValues = new LabelEnumeration(labelString);		while (theValues.hasMoreElements()) {			String label = (String)theValues.nextElement();			catLabels.addElement(new LabelValue(label));		}	}		public void setLabels(Value[] newLabels) {		catLabels.removeAllElements();		for (int i=0 ; i<newLabels.length ; i++)			catLabels.addElement(newLabels[i]);		originalIndex = null;	}		public int noOfCategories() {		return catLabels.size();	}		public Value getLabel(int index) {		return (Value)catLabels.elementAt(index);	}		public void changeLabelIndex(int oldIndex, int newIndex) {		Object moveLabel = catLabels.elementAt(oldIndex);		catLabels.removeElementAt(oldIndex);		catLabels.insertElementAt(moveLabel, newIndex);				if (originalIndex == null) {			int noOfCats = noOfCategories();			originalIndex = new Vector(noOfCats);			for (int i=0 ; i<noOfCats ; i++)				originalIndex.addElement(Integer.valueOf(i));		}		Object moveLabelIndex = originalIndex.elementAt(oldIndex);		originalIndex.removeElementAt(oldIndex);		originalIndex.insertElementAt(moveLabelIndex, newIndex);	}		public int originalLabelIndex(int newIndex) {		if (originalIndex == null)			return newIndex;		else			return ((Integer)originalIndex.elementAt(newIndex)).intValue();	}		protected Value valFromString(String s) {		return getLabel(Integer.parseInt(s));	}		public int getMaxWidth(Graphics g) {		//	does not need to ask individual values		int maxWidth = 0;//		FontMetrics fm = g.getFontMetrics();		Enumeration e = catLabels.elements();		while (e.hasMoreElements()) {			Value catLabel = (Value)e.nextElement();			int valWidth = catLabel.stringWidth(g);			if (valWidth > maxWidth)				maxWidth = valWidth;		}		return maxWidth;	}		public void setValues(int values[]) {		try {			if (usesGroups()) {				int previousCat = 0;				int countSoFar = 0;				clearData();				for (int i=0 ; i<values.length ; i++)					if (values[i] == previousCat)						countSoFar ++;					else {						if (countSoFar > 0)							addGroup(new RepeatValue(getLabel(previousCat), countSoFar));						countSoFar = 1;						previousCat = values[i];					}				if (countSoFar > 0)					addGroup(new RepeatValue(getLabel(previousCat), countSoFar));			}			else {				setNoOfGroups(values.length);				for (int i=0 ; i<values.length ; i++)					setValueAt(getLabel(values[i]), i);			}		} catch (Exception e) {			System.err.println("Category out of bounds error");		}	}		public int getItemCategory(int itemIndex) {		return labelIndex(valueAt(itemIndex));	}		public int labelIndex(Value v) {		return catLabels.indexOf(v);	}		public void setCounts(int count[]) {		int noOfCats = noOfCategories();		clearData();		for (int i=0 ; i<count.length ; i++)			addGroup(new RepeatValue(getLabel(i % noOfCats), count[i]));	}		public int[] getCounts() {		int labelCount = noOfCategories();		int count[] = new int[labelCount];		if (usesGroups()) {			ValueEnumeration ve = values();			while (ve.hasMoreValues()) {				RepeatValue group = ve.nextGroup();				count[labelIndex(group.val)] += group.count;			}		}		else			for (int i=0 ; i<noOfValues() ; i++)				count[getItemCategory(i)] ++;		return count;	}		public int[][] getCounts(Variable v) {					//	if v is not a CatVariable, it must be a NumVariable with (grouped) values					//	corresponding to pairs of category groups		int thisLabelCount = noOfCategories();		boolean catNotNum = v instanceof CatVariable;		CatVariable otherCat = catNotNum ? (CatVariable)v : null;		int otherLabelCount = catNotNum ? otherCat.noOfCategories() : v.getNoOfGroups();		int count[][] = new int[thisLabelCount][otherLabelCount];		if (usesGroups() || v.usesGroups()) {			ValueEnumeration ve1 = values();			ValueEnumeration ve2 = v.values();			int count1 = 0;			int count2 = 0;			int index1 = -1;			int index2 = -1;			while ((count1 > 0 || ve1.hasMoreValues()) && (count2 > 0 || ve2.hasMoreValues())) {				if (count1 == 0) {					RepeatValue group = ve1.nextGroup();					index1 = labelIndex(group.val);					count1 = group.count;				};				if (count2 == 0) {					RepeatValue group = ve2.nextGroup();					index2 = catNotNum ? otherCat.labelIndex(group.val) : (index2 + 1);					count2 = group.count;				};									int thisCount = Math.min(count1, count2);				count[index1][index2] += thisCount;				count1 -= thisCount;				count2 -= thisCount;			}		}		else			for (int i=0 ; i<noOfValues() ; i++)				count[getItemCategory(i)][otherCat.getItemCategory(i)] ++;		return count;	}		public int[][][] getCounts(CatVariable v2, CatVariable v3) {		int labelCount1 = noOfCategories();		int labelCount2 = v2.noOfCategories();		int labelCount3 = v3.noOfCategories();		int count[][][] = new int[labelCount1][labelCount2][labelCount3];		if (usesGroups() || v2.usesGroups() || v3.usesGroups()) {			ValueEnumeration ve1 = values();			ValueEnumeration ve2 = v2.values();			ValueEnumeration ve3 = v3.values();			int count1 = 0;			int count2 = 0;			int count3 = 0;			int index1 = -1;			int index2 = -1;			int index3 = -1;			while ((count1 > 0 || ve1.hasMoreValues()) && (count2 > 0 || ve2.hasMoreValues())																	 && (count3 > 0 || ve3.hasMoreValues())) {				if (count1 == 0) {					RepeatValue group = ve1.nextGroup();					index1 = labelIndex(group.val);					count1 = group.count;				};				if (count2 == 0) {					RepeatValue group = ve2.nextGroup();					index2 = v2.labelIndex(group.val);					count2 = group.count;				};				if (count3 == 0) {					RepeatValue group = ve3.nextGroup();					index3 = v3.labelIndex(group.val);					count3 = group.count;				};									int thisCount = Math.min(Math.min(count1, count2), count3);				count[index1][index2][index3] += thisCount;				count1 -= thisCount;				count2 -= thisCount;				count3 -= thisCount;			}		}		else			for (int i=0 ; i<noOfValues() ; i++)				count[getItemCategory(i)][v2.getItemCategory(i)][v3.getItemCategory(i)] ++;		return count;	}		public Flags getCatIndices(int cat) {		Value target = getLabel(cat);		ValueEnumeration ve = values();		int noOfGroups = 0;		boolean previousOnTarget = true;		while (ve.hasMoreValues()) {			RepeatValue group = ve.nextGroup();			boolean nextOnTarget = (group.val == target);			if (previousOnTarget != nextOnTarget) {				noOfGroups ++;				previousOnTarget = nextOnTarget;			}		}		Flags result = new Flags(noOfValues());		if (noOfGroups > 0) {			noOfGroups ++;			if ((noOfGroups & 0x1) != 0)		//		odd				noOfGroups ++;			if (noOfGroups < 4)				noOfGroups = 4;			int counts[] = new int[noOfGroups];			ve = values();			int groupIndex = 0;			int groupCount = 0;			previousOnTarget = true;			while (ve.hasMoreValues()) {				RepeatValue group = ve.nextGroup();				boolean nextOnTarget = (group.val == target);				if (previousOnTarget == nextOnTarget)					groupCount += group.count;				else {					counts[groupIndex] = groupCount;					groupIndex ++;					previousOnTarget = nextOnTarget;					groupCount = group.count;				}			}			counts[groupIndex] = groupCount;			result.setFlags(counts);		}		return result;	}}