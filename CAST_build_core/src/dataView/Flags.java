package dataView;abstract class FlagAction {	abstract void add(int minCum, int maxCum);}class CountFlagAction extends FlagAction {	private int index = 0;		void add(int minCum, int maxCum) {		if (index == 0)			if (minCum == 0)				index = 1;			else				index = 3;		else			index += 2;	}		int getNoOfCounts() {		return Math.max(index + 1, 4);	}}class AddFlagAction extends FlagAction {	private int counts[];	private int index = 0;	private int flagsToGo;	private int previousCum = 0;		AddFlagAction(int[] counts, int totalFlags) {		this.counts = counts;		flagsToGo = totalFlags;	}		void add(int minCum, int maxCum) {		if (index == 0) {			if (minCum == 0) {				counts[0] = maxCum;				flagsToGo -= maxCum;				counts[1] = flagsToGo;		//	complete false count in case this is the last group				index = 1;			}			else {				counts[0] = 0;				counts[1] = minCum;				counts[2] = maxCum - minCum;				flagsToGo -= maxCum;				counts[3] = flagsToGo;		//	complete false count in case this is the last group				index = 3;			}		}		else {			counts[index] = minCum - previousCum;			counts[index + 1] = maxCum - minCum;			flagsToGo -= (maxCum - previousCum);			counts[index + 2] = flagsToGo;		//	complete false count in case this is the last group			index += 2;		}		previousCum = maxCum;	}}class FlagIterator {	int cumCount, trueCount, falseCount;		private Flags f;	private int nextIndex;		FlagIterator(Flags f) {		this.f = f;		if (f.counts[0] == 0) {			cumCount = f.counts[1];			trueCount = f.counts[2];			falseCount = f.counts[3];			nextIndex = 4;		}		else {			cumCount = 0;			trueCount = f.counts[0];			falseCount = f.counts[1];			nextIndex = 2;		}	}		void takeNext() {		cumCount += (trueCount + falseCount);		if (cumCount >= f.noOfFlags) {			trueCount = 0;			falseCount = 0;		}		else {			trueCount = f.counts[nextIndex ++];			falseCount = f.counts[nextIndex ++];		}	}		boolean hasMore() {		return cumCount < f.noOfFlags;	}}public class Flags {	public int counts[];	int noOfFlags;		public Flags(int noOfFlags) {		checkSize(noOfFlags);	}		public int getNoOfFlags() {		return noOfFlags;	}		public void checkSize(int noOfFlags) {		this.noOfFlags = noOfFlags;		if (counts == null || counts.length != 4)												//		length 4 for most common case of a single index			counts = new int[4];		counts[0] = 0;		counts[1] = noOfFlags;		counts[2] = 0;		counts[3] = 0;	}		public boolean valueAt(int index) {		int cumCount = 0;		for (int i=0 ; i<counts.length ; i++) {			if (cumCount <= index)				cumCount += counts[i];			else				return (i & 0x01) != 0;		//		true if previous index was odd		}		return false;		//		This should never be called	}		public FlagEnumeration getEnumeration() {		return new FlagEnumeration(this);	}		public boolean clearFlags() {		boolean changed = counts[0] != 0 || counts[1] != noOfFlags;		checkSize(noOfFlags);		return changed;	}		public int findSingleSetFlag() {		//		if there is only one flag set, this returns it													//		(used by SummaryDataSet)		if (counts[0] == 1 && counts[1] == noOfFlags - 1)			return 0;		else if (counts[0] + counts[2] == 1 && counts[1] + counts[3] == noOfFlags - 1)			return counts[1];		else			return -1;	}		public int findFirstSetFlag() {		if (counts[0] == 0 && counts[1] == noOfFlags)			return -1;		if (counts[0] > 0)			return 0;		else			return counts[1];	}		public int findLastSetFlag() {		if (counts[0] == 0 && counts[1] == noOfFlags)			return -1;				int cumCount = 0;		int index2 = 0;		while (cumCount + counts[index2] + counts[index2 + 1] < noOfFlags) {			cumCount += counts[index2] + counts[index2 + 1];			index2 += 2;		}				return cumCount + counts[index2] - 1;	}		public boolean setFlag(int newIndex) {		if (newIndex == 0 && counts[0] == 1 && counts[1] == noOfFlags - 1)			return false;		else if (counts[0] == 0 && counts[1] == newIndex && counts[2] == 1																	&& counts[3] == noOfFlags - newIndex - 1)			return false;				checkSize(noOfFlags);		if (newIndex == 0) {			counts[0] = 1;			counts[1] = noOfFlags - 1;			counts[2] = 0;		}		else {			counts[0] = 0;			counts[1] = newIndex;			counts[2] = 1;			counts[3] = noOfFlags - newIndex - 1;		}		return true;	}		public boolean setFlags(boolean[] newFlags) {		if (newFlags.length != noOfFlags)			System.err.println("Wrong number of flags passed" + newFlags.length + " not " + noOfFlags);		boolean currentFlag = true;		int countSoFar = 0;		int flagIndex = 0;//		int groupIndex = 0;				boolean changed = false;		for (int i=0 ; i<newFlags.length ; i++)			if (newFlags[i] == currentFlag)				countSoFar ++;			else {				if (flagIndex >= counts.length || counts[flagIndex] != countSoFar)					changed = true;				flagIndex ++;				countSoFar = 1;				currentFlag = !currentFlag;			}		if (flagIndex >= counts.length || counts[flagIndex] != countSoFar)			changed = true;		flagIndex ++;		if (currentFlag)			flagIndex ++;				if (!changed)			return false;				int noOfGroups = Math.max(4, flagIndex);		if (noOfGroups != counts.length)			counts = new int[noOfGroups];				currentFlag = true;		countSoFar = 0;		flagIndex = 0;		for (int i=0 ; i<newFlags.length ; i++)			if (currentFlag == newFlags[i])				countSoFar ++;			else {				counts[flagIndex] = countSoFar;				countSoFar = 1;				currentFlag = !currentFlag;				flagIndex ++;			}		counts[flagIndex++] = countSoFar;		if (currentFlag)			counts[flagIndex++] = 0;				return true;	}		public boolean setFlags(int startIndex, int repeats) {		if (counts.length == 4) {			if (startIndex == 0)				if (counts[0] == repeats && counts[1] == noOfFlags - repeats)					return false;			else				if (counts[0] == 0 && counts[1] == startIndex && counts[2] == repeats && counts[3] == noOfFlags - repeats - 1)					return false;		}				checkSize(noOfFlags);				if (startIndex == 0) {			counts[0] = repeats;			counts[1] = noOfFlags - repeats;			counts[2] = 0;		}		else {			counts[0] = 0;			counts[1] = startIndex;			counts[2] = repeats;			counts[3] = noOfFlags - repeats - 1;		}		return true;	}		public boolean setFlags(int[] newGroups) {		boolean changed = true;		if (newGroups.length == counts.length) {			changed = false;			for (int i=0 ; i<counts.length ; i++)				if (newGroups[i] != counts[i]) {					changed = true;					break;				}		}		else			counts = new int[newGroups.length];		if (!changed)			return false;		for (int i=0 ; i<newGroups.length ; i++)			counts[i] = newGroups[i];		return true;	}		public void invertFlag(int index) {		if (counts[0] == 0 && counts[1] == noOfFlags)		//		nothing selected			setFlag(index);		else if (index == 0 && counts[0] == 1 && counts[1] == noOfFlags - 1						|| index != 0 && counts[0] == 0 && counts[2] == 1							&& counts[1] + counts[3] == noOfFlags - 1) {			counts[0] = 0;												//		only indexed item selected			counts[1] = noOfFlags;			counts[2] = 0;		}		else 			System.err.println("Cannot invert item's selection when more than one selected");										//		This can be done, but it complex	}		public boolean isSelected(Flags test) {		if (counts[0] == 0 && counts[1] == noOfFlags)			return false;				int startIndex0 = 0;		int index0 = 0;				int startIndex1 = 0;		int index1 = 0;				while (startIndex0 < noOfFlags) {			int repeats = test.counts[index0];						while (index1 < counts.length && startIndex1 + counts[index1] < startIndex0) {				startIndex1 += counts[index1] + counts[index1 + 1];				index1 += 2;			}			if (index1 >= counts.length || startIndex0 < startIndex1													|| startIndex0 + repeats > startIndex1 + counts[index1])				return false;						startIndex0 += repeats + test.counts[index0 + 1];			index0 += 2;		}		return true;	}		public int countSetFlags() {		int total = 0;		int totalSet = 0;		for (int i=0 ; i<counts.length ; i++) {			if (total >= noOfFlags)				break;			total += counts[i];			if (i % 2 == 0)				totalSet += counts[i];		}		return totalSet;	}		public boolean equals(Flags test) {		if (counts.length != test.counts.length)			return false;		int startIndex = 0;		int index = 0;				while (startIndex < noOfFlags) {			int repeats = counts[index];			if (test.counts[index] != repeats)				return false;						startIndex += repeats;			index ++;		}		return true;	}		private void orLoop(Flags test, FlagAction action) {		FlagIterator fi[] = new FlagIterator[2];		fi[0] = new FlagIterator(this);		fi[1] = new FlagIterator(test);		while (fi[0].hasMore() && fi[1].hasMore()) {			int lowCount = Math.min(fi[0].cumCount, fi[1].cumCount);			int lowIndex = 0;			while (true) {				lowIndex = (fi[0].cumCount <= fi[1].cumCount) ? 0 : 1;				if (fi[lowIndex].cumCount + fi[lowIndex].trueCount < fi[1 - lowIndex].cumCount) {					action.add(lowCount, lowCount + fi[lowIndex].trueCount);					fi[lowIndex].takeNext();					lowCount = Math.min(fi[0].cumCount, fi[1].cumCount);				}				else					break;			}							//		we now have overlapping flag groups			int highIndex = (fi[0].cumCount + fi[0].trueCount >= fi[1].cumCount + fi[1].trueCount) ? 0 : 1;			int highCount = fi[highIndex].cumCount + fi[highIndex].trueCount;			while (highCount < noOfFlags										&& fi[1 - highIndex].cumCount + fi[1 - highIndex].trueCount												+ fi[1 - highIndex].falseCount <= highCount) {				fi[1 - highIndex].takeNext();				highIndex = (fi[0].cumCount + fi[0].trueCount >= fi[1].cumCount + fi[1].trueCount)																										? 0 : 1;				highCount = fi[highIndex].cumCount + fi[highIndex].trueCount;			}			action.add(lowCount, highCount);			fi[lowIndex].takeNext();		}	}		public Flags or(Flags test) {		CountFlagAction counter = new CountFlagAction();		orLoop(test, counter);		Flags result = new Flags(noOfFlags);		result.counts = new int[counter.getNoOfCounts()];		result.counts[1] = noOfFlags;		AddFlagAction adder = new AddFlagAction(result.counts, noOfFlags);		orLoop(test, adder);		return result;	}		private void andLoop(Flags test, FlagAction action) {		FlagIterator fi[] = new FlagIterator[2];		fi[0] = new FlagIterator(this);		fi[1] = new FlagIterator(test);		while (fi[0].hasMore() && fi[1].hasMore()) {			int lowCount = Math.max(fi[0].cumCount, fi[1].cumCount);			int lowIndex = 0;			while (true) {				lowIndex = (fi[0].cumCount <= fi[1].cumCount) ? 0 : 1;				if (fi[lowIndex].cumCount + fi[lowIndex].trueCount <= fi[1 - lowIndex].cumCount) {					fi[lowIndex].takeNext();					lowCount = Math.max(fi[0].cumCount, fi[1].cumCount);					if (lowCount == noOfFlags)						return;				}				else					break;			}							//		we now have overlapping flag groups			int highIndex = (fi[0].cumCount + fi[0].trueCount <= fi[1].cumCount + fi[1].trueCount) ? 0 : 1;			int highCount = Math.max(fi[0].cumCount + fi[0].trueCount,																			fi[1].cumCount + fi[1].trueCount);			action.add(lowCount, highCount);			fi[1 - highIndex].takeNext();		}	}		public Flags and(Flags test) {		CountFlagAction counter = new CountFlagAction();		andLoop(test, counter);		Flags result = new Flags(noOfFlags);		result.counts = new int[counter.getNoOfCounts()];		result.counts[1] = noOfFlags;		AddFlagAction adder = new AddFlagAction(result.counts, noOfFlags);		andLoop(test, adder);		return result;	}		public int noOfSetFlags() {		FlagIterator fi = new FlagIterator(this);		int noSet = fi.trueCount;		while (fi.hasMore()) {			fi.takeNext();			noSet += fi.trueCount;		}		return noSet;	}}