package random;public class RandomBinomial extends RandomDiscrete {	static final private int kMaxMeanForBinomialSeries = 40;		protected int n;	protected double p;		private double mean_B, mult_B, pOverQ_B, p0_B;		public RandomBinomial(int count, int n, double p) {		super(count);		this.n = n;		this.p = p;				initialiseBinomial();	}		public void setN(int n) {		this.n = n;		initialiseBinomial();	}		public void setParameters(int n, double p) {		this.n = n;		this.p = p;		initialiseBinomial();	}		private void initialiseBinomial() {		double localP = (p > 0.5) ? 1.0 - p : p;				if (localP > 0.0) {			mean_B = n * localP;			if (mean_B > kMaxMeanForBinomialSeries)				mult_B = Math.sqrt(mean_B * (1.0 - localP));			else {				pOverQ_B = localP / (1.0 - localP);				p0_B = Math.pow(1.0 - localP, n);			}		}		else			mean_B = 0.0;	}		private int generateSmall(double p0) {		if (p0 <= 0.0)			return 0;		else if (mean_B > kMaxMeanForBinomialSeries) {			int i = (int)Math.round(mean_B + mult_B * nextGaussian());			return Math.max(0, Math.min(n, i));		}		else {			double term = p0_B;			double cumProb = term;			double randomVal = nextDouble();			int maxResult = Math.min(n, 100);			for (int i=0 ; i<maxResult ; i++)				if (randomVal <= cumProb)					return i;				else {					term *= pOverQ_B * (n - i) / (i + 1);					cumProb += + term;				}			return maxResult;		}	}		public int generateOne() {		if (p > 0.5)			return n - generateSmall(1.0 - p);		else			return generateSmall(p);	}}