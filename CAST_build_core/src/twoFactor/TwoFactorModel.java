package twoFactor;import java.util.*;import dataView.*;import models.*;public class TwoFactorModel extends CoreModelVariable {	static final public int NONE = 0;	static final public int LINEAR = 1;	static final public int FACTOR = 2;		private CatVariable xVar, zVar;	private int nx, nz;		private int xVarType, zVarType;	private boolean hasInteraction;		private double mean[][];	private boolean canDrag[][];	//	private int decimals;		public TwoFactorModel(String name, DataSet data, String[] xKey, int xVarType, int zVarType,																		boolean hasInteraction, double commonMean) {																		//		only for situations where parameters																		//		are set by LS immediately after		super(name, data, xKey);		xVar = (CatVariable)data.getVariable(xKey[0]);		zVar = (CatVariable)data.getVariable(xKey[1]);		nx = xVar.noOfCategories();		nz = zVar.noOfCategories();			mean = new double[nx][nz];		for (int i=0 ; i<nx ; i++)			for (int j=0 ; j<nz ; j++)				mean[i][j] = commonMean;		setModelType(xVarType, zVarType, hasInteraction);	}		public void setModelType(int newXVarType, int newZVarType, boolean newHasInteraction) {		xVarType = newXVarType;		zVarType = newZVarType;		hasInteraction = newHasInteraction;		if (canDrag == null)			canDrag = new boolean[nx][nz];		//	initialised to false		else			for (int i=0 ; i<nx ; i++)				for (int j=0 ; j<nz ; j++)					canDrag[i][j] = false;				int xStep = (newXVarType == NONE) ? nx : (newXVarType == LINEAR) ? (nx - 1) : 1;		int zStep = (newZVarType == NONE) ? nz : (newZVarType == LINEAR) ? (nz - 1) : 1;		for (int i=0 ; i<nx ; i+=xStep)			canDrag[i][0] = true;		for (int j=zStep ; j<nz ; j+=zStep)			canDrag[0][j] = true;				if (newHasInteraction)			for (int i=xStep ; i<nx ; i+=xStep)				for (int j=zStep ; j<nz ; j+=zStep)					canDrag[i][j] = true;				setNonDragMeans();	}		public int getXVarType() {		return xVarType;	}		public int getZVarType() {		return zVarType;	}		public boolean getHasInteraction() {		return hasInteraction;	}		public boolean canDragMean(int xCat, int zCat) {		return canDrag[xCat][zCat];	}		public void setDragMean(int xCat, int zCat, double newMean) {		if (canDrag[xCat][zCat]) {			mean[xCat][zCat] = newMean;			setNonDragMeans();		}	}		public void setParameters(String params) {		StringTokenizer st = new StringTokenizer(params);		if (st.countTokens() != nx * nz) {			System.out.println("Wrong number of means to initialise TwoFactorModel");			return;		}				for (int i=0 ; i<nx ; i++)			for (int j=0 ; j<nz ; j++)				mean[i][j] = Double.parseDouble(st.nextToken());	}		public int noOfParameters() {		int nParam;		if (hasInteraction) {			int nxParams = (xVarType == FACTOR) ? nx : (xVarType == LINEAR) ? 2 : 1;			int nzParams = (zVarType == FACTOR) ? nz : (zVarType == LINEAR) ? 2 : 1;			nParam = nxParams * nzParams;		}		else {			nParam = 1;			if (xVarType == LINEAR)				nParam ++;			else if (xVarType == FACTOR)				nParam += (nx - 1);							if (zVarType == LINEAR)				nParam ++;			else if (zVarType == FACTOR)				nParam += (nz - 1);		}		return nParam;	}		private double[] getMainEffectVector(int varType, int cat, int nCats) {		if (varType == NONE)			return new double[0];		else if (varType == LINEAR) {			double result[] = new double[1];			result[0] = cat / (double)(nCats - 1);			return result;		}		else {			double result[] = new double[nCats - 1];			for (int i=1 ; i<nCats ; i++)				result[i - 1] = (i == cat) ? 1 : 0;			return result;		}	} 		private void fillXVector(int xCat, int zCat, double[] xy) {		xy[0] = 1.0;		int paramIndex = 1;				double xVector[] = getMainEffectVector(xVarType, xCat, nx);		for (int i=0 ; i<xVector.length ; i++)			xy[paramIndex ++] = xVector[i];				double zVector[] = getMainEffectVector(zVarType, zCat, nz);		for (int i=0 ; i<zVector.length ; i++)			xy[paramIndex ++] = zVector[i];				if (hasInteraction)			for (int i=0 ; i<xVector.length ; i++)				for (int j=0 ; j<zVector.length ; j++)					xy[paramIndex ++] = xVector[i] * zVector[j];	}		public void setLSParams(String yKey) {		int nParam = noOfParameters();				double[] xy = new double[nParam + 1];		double[] r = initSsqMatrix(nParam + 1);				NumVariable yVar = (NumVariable)data.getVariable(yKey);				try {			for (int i=0 ; i<yVar.noOfValues() ; i++) {				int xCat = xVar.getItemCategory(i);				int zCat = zVar.getItemCategory(i);				fillXVector(xCat, zCat, xy);				double y = yVar.doubleValueAt(i);				if (!Double.isNaN(y)) {					xy[xy.length - 1] = y;					givenC(r, xy, 1.0);				}			}						double[] bValue = bSub(r, nParam + 1, null);//			System.out.println("Param estimates");//			for (int i=0 ; i<bValue.length ; i++)//				System.out.println("b[" + i + "] = " + bValue[i]);						for (int xCat=0 ; xCat<nx ; xCat++)				for (int zCat=0 ; zCat<nz ; zCat++) {					fillXVector(xCat, zCat, xy);					double m = 0.0;					for (int j=0 ; j<bValue.length ; j++)						m += bValue[j] * xy[j];											mean[xCat][zCat] = m;				}		} catch (GivensException e) {			System.err.println(e);		}	}		public void setNonDragMeans() {		int nParam = noOfParameters();				double[] xy = new double[nParam + 1];		double[] r = initSsqMatrix(nParam + 1);				try {			for (int xCat=0 ; xCat<nx ; xCat++)				for (int zCat=0 ; zCat<nz ; zCat++)					if (canDrag[xCat][zCat]) {						fillXVector(xCat, zCat, xy);						xy[xy.length - 1] = mean[xCat][zCat];						givenC(r, xy, 1.0);					}						double[] bValue = bSub(r, nParam + 1, null);						for (int xCat=0 ; xCat<nx ; xCat++)				for (int zCat=0 ; zCat<nz ; zCat++)					if (!canDrag[xCat][zCat]) {						fillXVector(xCat, zCat, xy);						double m = 0.0;						for (int j=0 ; j<bValue.length ; j++)							m += bValue[j] * xy[j];													mean[xCat][zCat] = m;					}		} catch (GivensException e) {			System.err.println(e);		}	}		public void updateLSParams(String yKey) {		setLSParams(yKey);	}		public double evaluateMean(int xCat, int zCat) {		return mean[xCat][zCat];	}		public double evaluateMean(Value[] x) {		int xCat = xVar.labelIndex(x[0]);		int zCat = zVar.labelIndex(x[1]);		return evaluateMean(xCat, zCat);	}	}