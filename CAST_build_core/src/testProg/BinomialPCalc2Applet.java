package testProg;import dataView.*;import test.*;import qnUtils.*;import distn.*;import randomStatProg.*;public class BinomialPCalc2Applet extends BinomialCalc2Applet {	protected boolean testNotProb() {		return true;	}		protected String[] getAnswerStrings() {		String nString = question.getValueString(QuestionLayout.N);		int n = Integer.parseInt(nString);				String piString = question.getValueString(QuestionLayout.PI);		double pi = Double.parseDouble(piString);				String xString = question.getValueString(QuestionLayout.X1_VALUE);		int x = Integer.parseInt(xString);				String solnString = "The exact value is " + answer.toString();				String adviceString = "Find the mean and standard deviation of the number of successes. Then find z corresponding to ";		switch (test.getTestTail()) {			case HypothesisTest.HA_LOW:				adviceString = adviceString + String.valueOf(x) + ".5. The p-value is the standard normal area below z.";				break;			case HypothesisTest.HA_HIGH:				adviceString = adviceString + String.valueOf(x - 1) + ".5. The p-value is the standard normal area above z.";				break;			case HypothesisTest.HA_NOT_EQUAL:			default:				if (x > n * pi)					adviceString = adviceString + String.valueOf(x - 1) + ".5. The p-value is twice the standard normal area above z.";				else					adviceString = adviceString + String.valueOf(x) + ".5. The p-value is twice the standard normal area below z.";				break;		}				String accuracyString = (new NumValue(approxSlop * 100, 0)).toString();				String answerString[] = new String[5];				answerString[LinkedAnswerEditPanel.NONE] = "Find the p-value to within " + accuracyString										+ "% of the correct value. Then select your conclusion.";		answerString[LinkedAnswerEditPanel.EXACT] = "P-value is correct!  " + solnString;		answerString[LinkedAnswerEditPanel.WRONG] = "P-value is wrong.  " + adviceString;		answerString[LinkedAnswerEditPanel.UNKNOWN] = "Error! You have not typed a valid number.";		answerString[LinkedAnswerEditPanel.CLOSE] = "P-value is close enough!  " + solnString;		return answerString;	}		protected HypothesisTest findTestInfo(String tailString, String[] paramString) {		int testTail;		if (tailString.equals("low"))			testTail = HypothesisTest.HA_LOW;		else if (tailString.equals("high"))			testTail = HypothesisTest.HA_HIGH;		else			testTail = HypothesisTest.HA_NOT_EQUAL;		return new UnivarHypothesisTest(null, null, new NumValue(paramString[7]), testTail, HypothesisTest.PROPN_APPROX, this);	}		protected void setupAnswer() {		String nString = question.getValueString(QuestionLayout.N);		int n = Integer.parseInt(nString);				String piString = question.getValueString(QuestionLayout.PI);		double pi = Double.parseDouble(piString);				String xString = question.getValueString(QuestionLayout.X1_VALUE);		double x = Double.parseDouble(xString);				double sd = Math.sqrt(n * pi * (1.0 - pi));				double pValue = 0.0;		if (tailString.equals("low"))			pValue = NormalTable.cumulative((x + 0.5 - n * pi) / sd);		else if (tailString.equals("high"))			pValue = 1.0 - NormalTable.cumulative((x - 0.5 - n * pi) / sd);		else {			if (x > n * pi)				pValue = 2.0 * (1.0 - NormalTable.cumulative((x - 0.5 - n * pi) / sd));			else				pValue = 2.0 * NormalTable.cumulative((x + 0.5 - n * pi) / sd);			if (pValue > 1.0)				pValue = 1.0;		}				answer = new NumValue(pValue, 4);	}		protected double getAccuracy(double slopValue) {		return Math.max(0.001, slopValue * answer.toDouble());	}}